<?xml version="1.0" encoding="utf-8" ?>
<Comments>
  <Codes id="NCDK.Aromaticities.Aromaticity_Example.cs">
    <code>                // mimics the old CDKHuckelAromaticityDetector which uses the CDK atom types
                ElectronDonation model = ElectronDonation.CDKModel;
                CycleFinder cycles = Cycles.CDKAromaticSetFinder;
                Aromaticity aromaticity = new Aromaticity(model, cycles);
                // apply our configured model to each molecule, the CDK model
                // requires that atom types are perceived
                var molecule = TestMoleculeFactory.MakeAnthracene();
                AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(molecule);
                aromaticity.Apply(molecule);
</code>
  </Codes>
  <Codes id="NCDK.Aromaticities.Aromaticity_Example.cs+ctor">
    <code>                // mimics the CDKHuckelAromaticityDetector
                Aromaticity aromaticity_cdk = new Aromaticity(ElectronDonation.CDKModel, Cycles.CDKAromaticSetFinder);
                // mimics the DoubleBondAcceptingAromaticityDetector
                Aromaticity aromaticity_exo = new Aromaticity(ElectronDonation.CDKAllowingExocyclicModel, Cycles.CDKAromaticSetFinder);
                // a good model for writing SMILES
                Aromaticity aromaticity_smi = new Aromaticity(ElectronDonation.DaylightModel, Cycles.AllFinder);
                // a good model for writing MDL/Mol2
                Aromaticity aromaticity_mdl = new Aromaticity(ElectronDonation.PiBondsModel, Cycles.AllFinder);
</code>
  </Codes>
  <Codes id="NCDK.Aromaticities.Aromaticity_Example.cs+FindBonds">
    <code>                Aromaticity aromaticity = new Aromaticity(ElectronDonation.CDKModel, Cycles.AllFinder);
                IAtomContainer container = TestMoleculeFactory.MakeAnthracene();
                AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(container);
                try
                {
                    var bonds = aromaticity.FindBonds(container);
                    int nAromaticBonds = bonds.Count();
                }
                catch (CDKException)
                {
                    // cycle computation was intractable
                }
</code>
  </Codes>
  <Codes id="NCDK.Aromaticities.Aromaticity_Example.cs+Apply">
    <code>                Aromaticity aromaticity = new Aromaticity(ElectronDonation.CDKModel, Cycles.AllFinder);
                IAtomContainer container = TestMoleculeFactory.MakeAnthracene();
                try
                {
                    if (aromaticity.Apply(container))
                    {
                        //
                    }
                }
                catch (CDKException)
                {
                    // cycle computation was intractable
                }
</code>
  </Codes>
  <Codes id="NCDK.Aromaticities.Aromaticity_Example.cs+CDKLegacy_CDKAromaticSetFinder">
    <code>                new Aromaticity(ElectronDonation.CDKModel, Cycles.CDKAromaticSetFinder);
</code>
  </Codes>
  <Codes id="NCDK.Aromaticities.Aromaticity_Example.cs+CDKLegacy_AllFinder_RelevantFinder">
    <code>                new Aromaticity(ElectronDonation.CDKModel, Cycles.Or(Cycles.AllFinder, Cycles.RelevantFinder));
</code>
  </Codes>
  <Codes id="NCDK.Aromaticities.ElectronDonation_Example.cs">
    <code>                ElectronDonation model = ElectronDonation.CDKModel;
</code>
  </Codes>
  <Codes id="NCDK.Charges.MMFF94PartialCharges_Example.cs">
    <code>            SmilesParser sp = new SmilesParser(Silent.ChemObjectBuilder.Instance);
            IAtomContainer ac = sp.ParseSmiles("CC");
            AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(ac);
            AtomContainerManipulator.ConvertImplicitToExplicitHydrogens(ac);
            MMFF94PartialCharges mmff = new MMFF94PartialCharges();
            mmff.AssignMMFF94PartialCharges(ac);
</code>
  </Codes>
  <Codes id="NCDK.Charges.MMFF94PartialCharges_Example.cs+result">
    <code>                    atom.GetProperty&lt;double&gt;("MMFF94charge")
</code>
  </Codes>
  <Codes id="NCDK.Config.Elements_Example.cs+OfNumber">
    <code>                // carbon
                Elements c = Elements.OfNumber(6);
                // oxygen
                Elements o = Elements.OfNumber(8);
</code>
  </Codes>
  <Codes id="NCDK.Config.Elements_Example.cs+OfString">
    <code>                 Elements a = Elements.OfString("c");
                 Elements b = Elements.OfString("C");
                 Elements c = Elements.OfString("Carbon");
                 Elements d = Elements.OfString("carbon");
</code>
  </Codes>
  <Codes id="NCDK.Config.XMLIsotopeFactory_Example.cs+1">
    <code>                IsotopeFactory ifac = XMLIsotopeFactory.GetInstance(new ChemObject().Builder);
</code>
  </Codes>
  <Codes id="NCDK.Config.XMLIsotopeFactory_Example.cs+example">
    <code>                IsotopeFactory factory = XMLIsotopeFactory.GetInstance(Default.ChemObjectBuilder.Instance);
                IIsotope major = factory.GetMajorIsotope("H");
</code>
  </Codes>
  <Codes id="NCDK.Fingerprint.FingerprinterTool_Example.cs+IsSubset">
    <code>                var mol = TestMoleculeFactory.MakeIndole();
                var fingerprinter = new Fingerprinter();
                var bs = fingerprinter.GetBitFingerprint(mol);
                var frag1 = TestMoleculeFactory.MakePyrrole();
                var bs1 = fingerprinter.GetBitFingerprint(frag1);
                if (FingerprinterTool.IsSubset(bs.AsBitSet(), bs1.AsBitSet()))
                {
                    Console.Out.WriteLine("Pyrrole is subset of Indole.");
                }
</code>
  </Codes>
  <Codes id="NCDK.Fingerprint.Fingerprinter_Example.cs">
    <code>                var molecule = new AtomContainer();
                var fingerprinter = new Fingerprinter();
                var fingerprint = fingerprinter.GetBitFingerprint(molecule);
                Console.WriteLine(fingerprint.Count); // returns 1024 by default
</code>
  </Codes>
  <Codes id="NCDK.Fingerprint.HybridizationFingerprinter_Example.cs">
    <code>                var molecule = new AtomContainer();
                var fingerprinter = new HybridizationFingerprinter();
                var fingerprint = fingerprinter.GetBitFingerprint(molecule);
                Console.WriteLine(fingerprint.Count); // returns 1024 by default
</code>
  </Codes>
  <Codes id="NCDK.Fingerprint.PubchemFingerprinter_Example.cs">
    <code>                var molecule = new AtomContainer();
                IFingerprinter fingerprinter = new PubchemFingerprinter(Silent.ChemObjectBuilder.Instance);
                IBitFingerprint fingerprint = fingerprinter.GetBitFingerprint(molecule);
                Console.WriteLine(fingerprint.Count); // returns 881
</code>
  </Codes>
  <Codes id="NCDK.Fingerprint.ShortestPathFingerprinter_Example.cs">
    <code>                var molecule = new AtomContainer();
                AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(molecule);
                var fingerprinter = new ShortestPathFingerprinter();
                var fingerprint = fingerprinter.GetBitFingerprint(molecule);
                Console.WriteLine(fingerprint.Count); // returns 1024 by default
</code>
  </Codes>
  <Codes id="NCDK.ForceField.MMFF.MmffAtomTypeMatcher_Example.cs">
    <code>            MmffAtomTypeMatcher mmffAtomTypes = new MmffAtomTypeMatcher();
            foreach (var container in containers)
            {
                string[] symbs = mmffAtomTypes.SymbolicTypes(container);
            }
</code>
  </Codes>
  <Codes id="NCDK.ForceField.MMFF.Mmff_Example.cs">
    <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                Mmff mmff = new Mmff();
                mmff.AssignAtomTypes(mol);
                mmff.PartialCharges(mol);
                mmff.ClearProps(mol); // optional
</code>
  </Codes>
  <Codes id="NCDK.Formula.MolecularFormulaGenerator_Example.cs">
    <code>            IsotopeFactory ifac = Isotopes.Instance;
             IIsotope c = ifac.GetMajorIsotope("C");
             IIsotope h = ifac.GetMajorIsotope("H");
             IIsotope n = ifac.GetMajorIsotope("N");
             IIsotope o = ifac.GetMajorIsotope("O");
             IIsotope p = ifac.GetMajorIsotope("P");
             IIsotope s = ifac.GetMajorIsotope("S");
             
             MolecularFormulaRange mfRange = new MolecularFormulaRange();
             mfRange.Add(c, 0, 50);
             mfRange.Add(h, 0, 100);
             mfRange.Add(o, 0, 50);
             mfRange.Add(n, 0, 50);
             mfRange.Add(p, 0, 10);
             mfRange.Add(s, 0, 10);

            var builder = Silent.ChemObjectBuilder.Instance;
            double minMass = 133.003;
            double maxMass = 133.005;
            MolecularFormulaGenerator mfg = new MolecularFormulaGenerator(builder, minMass, maxMass, mfRange);
            IMolecularFormulaSet mfSet = mfg.GetAllFormulas();
</code>
  </Codes>
  <Codes id="NCDK.Geometries.Alignments.KabschAlignment_Example.cs">
    <code>                AtomContainer ac1 = new AtomContainer();    // molecule 1
                AtomContainer ac2 = new AtomContainer();    // molecule 2
                try
                {
                    KabschAlignment sa = new KabschAlignment(ac1.Atoms, ac2.Atoms);

                    sa.Align();
                    Console.Out.WriteLine(sa.RMSD);
                }
                catch (CDKException) { }
</code>
  </Codes>
  <Codes id="NCDK.Geometries.Alignments.KabschAlignment_Example.cs+substructure">
    <code>                AtomContainer ac1 = new AtomContainer();    // whole molecules
                AtomContainer ac2 = new AtomContainer();    // 
                IAtom[] a1 = ac1.Atoms.ToArray();   // some subsets of atoms from the two molecules
                IAtom[] a2 = ac2.Atoms.ToArray();   // 
                try
                {
                    var sa = new KabschAlignment(a1, a2);
                    sa.Align();

                    var cm1 = sa.CenterOfMass;
                    foreach (var a in ac1.Atoms)
                        a.Point3D = a.Point3D.Value - cm1;
                    sa.RotateAtomContainer(ac2);
                    // display the two AtomContainer's
                }
                catch (CDKException) { }
</code>
  </Codes>
  <Codes id="NCDK.Geometries.CIP.CIPTool_Example.cs">
    <code>            IAtom[] ligandAtoms = mol.GetConnectedAtoms(centralAtom).ToArray();
            ITetrahedralChirality tetraStereo = new TetrahedralChirality(centralAtom, ligandAtoms, TetrahedralStereo.AntiClockwise);
            CIPChirality cipChirality = CIPTool.GetCIPChirality(mol, tetraStereo);
</code>
  </Codes>
  <Codes id="NCDK.Geometries.RDFCalculator_Example.cs">
    <code>            RDFCalculator calculator = new RDFCalculator(0.0, 5.0, 0.1, 0.0,
                delegate(IAtom atom, IAtom atom2) { return atom.Charge.Value * atom2.Charge.Value; });
</code>
  </Codes>
  <Codes id="NCDK.Graphs.InChI.InChIGenerator_Example.cs">
    <code>            // Generate factory -  if native code does not load
            InChIGeneratorFactory factory = new InChIGeneratorFactory();
            // Get InChIGenerator
            InChIGenerator gen = factory.GetInChIGenerator(container);

            INCHI_RET ret = gen.ReturnStatus;
            if (ret == INCHI_RET.WARNING)
            {
                // InChI generated, but with warning message
                Console.WriteLine($"InChI warning: {gen.Message}");
            }
            else if (ret != INCHI_RET.OKAY)
            {
                // InChI generation failed
                throw new CDKException($"InChI failed: {ret.ToString()} [{gen.Message}]");
            }

            string inchi = gen.InChI;
            string auxinfo = gen.AuxInfo;
</code>
  </Codes>
  <Codes id="NCDK.Graphs.InChI.InChIToStructure_Example.cs">
    <code>            // Generate factory -  if native code does not load
             InChIGeneratorFactory factory = new InChIGeneratorFactory();
             // Get InChIToStructure
             InChIToStructure intostruct = factory.GetInChIToStructure(inchi, Default.ChemObjectBuilder.Instance);
             
             INCHI_RET ret = intostruct.ReturnStatus;
            if (ret == INCHI_RET.WARNING)
            {
                // Structure generated, but with warning message
                Console.WriteLine($"InChI warning: {intostruct.Message}");
            }
            else if (ret != INCHI_RET.OKAY)
            {
                // Structure generation failed
                throw new CDKException($"Structure generation failed failed: {ret.ToString()} [{intostruct.Message}]");
            }             
             IAtomContainer container = intostruct.AtomContainer;
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Invariant.Canon_Example.cs">
    <code>            IAtomContainer m = TestMoleculeFactory.MakeAlphaPinene();
            int[][] g = GraphUtil.ToAdjList(m);

            // obtain canon labelling
            long[] canon_labels = Canon.Label(m, g);

            // obtain symmetry classes
            long[] symmetry_labels = Canon.Symmetry(m, g);
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Invariant.ConjugatedPiSystemsDetector_Example.cs+Detect">
    <code>                Atom a0 = new Atom("C"); mol.Atoms.Add(a0);
                Atom a1 = new Atom("C"); mol.Atoms.Add(a1);
                Atom a2 = new Atom("C"); mol.Atoms.Add(a2);
                Atom h1 = new Atom("H"); mol.Atoms.Add(h1);
                Atom h2 = new Atom("H"); mol.Atoms.Add(h2);
                Atom h3 = new Atom("H"); mol.Atoms.Add(h3);
                Atom h4 = new Atom("H"); mol.Atoms.Add(h4);
                Atom h5 = new Atom("H"); mol.Atoms.Add(h5);
                mol.AddBond(a0, a1, BondOrder.Double);
                mol.AddBond(a1, a2, BondOrder.Single);
                mol.AddBond(a0, h1, BondOrder.Single);
                mol.AddBond(a0, h2, BondOrder.Single);
                mol.AddBond(a1, h3, BondOrder.Single);
                mol.AddBond(a2, h4, BondOrder.Single);
                mol.AddBond(a2, h5, BondOrder.Single);
                SingleElectron se = new SingleElectron(a2);
                mol.AddElectronContainer(se);

                var pi_systems = ConjugatedPiSystemsDetector.Detect(mol);
</code>
  </Codes>
  <Codes id="NCDK.Graphs.AllCycles_Example.cs">
    <code>using NCDK.RingSearches;
using NCDK.Templates;

namespace NCDK.Graphs
{
    class AllCycles_Example
    {
        public static void Main(string[] args)
        {
            // convert the molecule to adjacency list - may be redundant in future
            IAtomContainer m = TestMoleculeFactory.MakeAlphaPinene();
            int[][] g = GraphUtil.ToAdjList(m);

            // efficient computation/partitioning of the ring systems
            RingSearch rs = new RingSearch(m, g);

            // isolated cycles don't need to be run
            rs.Isolated();

            // process fused systems separately
            foreach (var fused in rs.Fused())
            {
                const int maxDegree = 100;
                // given the fused subgraph, max cycle size is
                // the number of vertices
                AllCycles ac = new AllCycles(GraphUtil.Subgraph(g, fused), fused.Length, maxDegree);
                // cyclic walks
                int[][] paths = ac.GetPaths();
            }
        }
    }
}
</code>
  </Codes>
  <Codes id="NCDK.Graphs.AllPairsShortestPaths_Example.cs">
    <code>                IAtomContainer benzene = TestMoleculeFactory.MakeBenzene();
                AllPairsShortestPaths apsp = new AllPairsShortestPaths(benzene);
                for (int i = 0; i &lt; benzene.Atoms.Count; i++)
                {
                    // only to half the comparisons, we can reverse the
                    // path[] to get all j to i
                    for (int j = i + 1; j &lt; benzene.Atoms.Count; j++)
                    {
                        // reconstruct shortest path from i to j
                        int[] path = apsp.From(i).GetPathTo(j);

                        // reconstruct all shortest paths from i to j
                        int[][] paths = apsp.From(i).GetPathsTo(j);

                        // reconstruct the atoms in the path from i to j
                        IAtom[] atoms = apsp.From(i).GetAtomsTo(j);

                        // access the number of paths from i to j
                        int nPaths = apsp.From(i).GetNPathsTo(j);

                        // access the distance from i to j
                        int distance = apsp.From(i).GetNPathsTo(j);
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.AllPairsShortestPaths_Example.cs+From">
    <code>                AllPairsShortestPaths apsp = new AllPairsShortestPaths(benzene);

                // access explicitly
                ShortestPaths sp = apsp.From(0);
                // or chain method calls
                int[] path = apsp.From(0).GetPathTo(5);
</code>
  </Codes>
  <Codes id="NCDK.Graphs.AllPairsShortestPaths_Example.cs+From_IAtom">
    <code>                AllPairsShortestPaths apsp = new AllPairsShortestPaths(molecule);
                IAtom start = molecule.Atoms[0];
                IAtom end = molecule.Atoms[1];

                // access explicitly
                ShortestPaths sp = apsp.From(start);
                
                 // or chain the method calls together
                
                 // first path from start to end atom
                 int[] path = apsp.From(start).GetPathTo(end);
                
                 // first atom path from start to end atom
                 IAtom[] atoms = apsp.From(start).GetAtomsTo(end);
</code>
  </Codes>
  <Codes id="NCDK.Graphs.AtomContainerAtomPermutor_Example.cs">
    <code>            AtomContainerAtomPermutor permutor = new AtomContainerAtomPermutor(container);
            while (permutor.MoveNext())
            {
                IAtomContainer permutedContainer = permutor.Current;
                // ...
            }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.AtomContainerBondPermutor_Example.cs">
    <code>            AtomContainerBondPermutor permutor = new AtomContainerBondPermutor(container);
            while (permutor.MoveNext())
            {
                IAtomContainer permutedContainer = permutor.Current;
                // ...
            }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ConnectedComponents_Example.cs">
    <code>            int[][] g = GraphUtil.ToAdjList(container);
            ConnectedComponents cc = new ConnectedComponents(g);
            int[] components = cc.Components();
            for (int v = 0; v &lt; g.Length; v++)
                Console.WriteLine(components[v]);
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ConnectivityChecker_Example.cs+1">
    <code>            bool isConnected = ConnectivityChecker.IsConnected(container);
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ConnectivityChecker_Example.cs+2">
    <code>            var fragments = ConnectivityChecker.PartitionIntoMolecules(disconnectedContainer);
            int fragmentCount = fragments.Count;
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+AllFinder">
    <code>				CycleFinder cf = Cycles.AllFinder;
				foreach (var container in containers) 
				{
					try
					{
						Cycles cycles = cf.Find(container);
						IRingSet rings  = cycles.ToRingSet();
					} 
					catch (IntractableException) 
					{
						// handle error - note it is common that finding all simple cycles in chemical graphs is intractable
					}
				}
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+MCB">
    <code>				CycleFinder cf = Cycles.AllFinder;
				foreach (var container in containers) 
				{
					try
					{
						Cycles cycles = cf.Find(container);
						IRingSet rings  = cycles.ToRingSet();
					} 
					catch (IntractableException) 
					{
						// ignore error - MCB should never be intractable
					}
				}
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+Relevant">
    <code>				CycleFinder cf = Cycles.AllFinder;
				foreach (var container in containers) 
				{
					try
					{
						Cycles cycles = cf.Find(container);
						IRingSet rings  = cycles.ToRingSet();
					} 
					catch (IntractableException) 
					{
						// ignore error - there may be an exponential number of cycles but this is not currently checked
					}
				}
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+Essential">
    <code>				CycleFinder cf = Cycles.AllFinder;
				foreach (var container in containers) 
				{
					try
					{
						Cycles cycles = cf.Find(container);
						IRingSet rings  = cycles.ToRingSet();
					} 
					catch (IntractableException) 
					{
						// ignore error - essential cycles do not check tractability
					}
				}
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+TripletShort">
    <code>				CycleFinder cf = Cycles.AllFinder;
				foreach (var container in containers) 
				{
					try
					{
						Cycles cycles = cf.Find(container);
						IRingSet rings  = cycles.ToRingSet();
					} 
					catch (IntractableException) 
					{
						// ignore error - triple short cycles do not check tractability
					}
				}
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+VertexShort">
    <code>				CycleFinder cf = Cycles.AllFinder;
				foreach (var container in containers) 
				{
					try
					{
						Cycles cycles = cf.Find(container);
						IRingSet rings  = cycles.ToRingSet();
					} 
					catch (IntractableException) 
					{
						// ignore error - vertex short cycles do not check tractability
					}
				}
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+EdgeShort">
    <code>				CycleFinder cf = Cycles.AllFinder;
				foreach (var container in containers) 
				{
					try
					{
						Cycles cycles = cf.Find(container);
						IRingSet rings  = cycles.ToRingSet();
					} 
					catch (IntractableException) 
					{
						// ignore error - edge short cycles do not check tractability
					}
				}
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+CDKAromaticSetFinder">
    <code>				CycleFinder cf = Cycles.AllFinder;
				foreach (var container in containers) 
				{
					try
					{
						Cycles cycles = cf.Find(container);
						IRingSet rings  = cycles.ToRingSet();
					} 
					catch (IntractableException) 
					{
						// ignore error - edge short cycles do not check tractability
					}
				}
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+AllOrVertexShortFinder">
    <code>				CycleFinder cf = Cycles.AllFinder;
				foreach (var container in containers) 
				{
					try
					{
						Cycles cycles = cf.Find(container);
						IRingSet rings  = cycles.ToRingSet();
					} 
					catch (IntractableException) 
					{
						// ignore error - edge short cycles do not check tractability
					}
				}
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+Or6">
    <code>                // all cycles or all cycles size &lt;= 6
                CycleFinder cf = Cycles.Or(Cycles.AllFinder, Cycles.GetAllFinder(6));
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+OrARE">
    <code>                // all cycles or relevant or essential
                CycleFinder cf = Cycles.Or(Cycles.AllFinder, Cycles.Or(Cycles.RelevantFinder, Cycles.EssentialFinder));
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+FindAll">
    <code>                foreach (var container in containers)
                {
                    try
                    {
                        Cycles cycles = Cycles.FindAll(container);
                        IRingSet rings = cycles.ToRingSet();
                    }
                    catch (IntractableException)
                    {
                        // handle error - note it is common that finding all simple cycles in chemical graphs is intractable
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+FindMCB">
    <code>                        Cycles cycles = Cycles.FindMCB(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+FindSSSR">
    <code>                        Cycles cycles = Cycles.FindSSSR(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+FindRelevant">
    <code>                        Cycles cycles = Cycles.FindRelevant(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+FindEssential">
    <code>                        Cycles cycles = Cycles.FindEssential(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+FindTripletShort">
    <code>                        Cycles cycles = Cycles.FindTripletShort(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+FindVertexShort">
    <code>                        Cycles cycles = Cycles.FindVertexShort(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.cs+FindEdgeShort">
    <code>                        Cycles cycles = Cycles.FindEdgeShort(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.GraphUtil_Example.cs+Subgraph">
    <code>            int[][] g = GraphUtil.ToAdjList(naphthalene);
            int[] vs = new int[] { 0, 1, 2, 3, 4, 5 };

            int[][] h = GraphUtil.Subgraph(g, vs);
            // for the vertices in h, the provided 'vs' gives the original index
            for (int v = 0; v &lt; h.Length; v++)
            {
                // vs[v] is 'v' in 'g'
            }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.RelevantCycles_Example.cs">
    <code>                // using NCDK.Graphs.GraphUtil;
                IAtomContainer m = TestMoleculeFactory.MakeAnthracene();

                // compute on the whole graph
                RelevantCycles relevant = new RelevantCycles(ToAdjList(m));

                // it is much faster to compute on the separate ring systems of the molecule
                int[][] graph = ToAdjList(m);
                RingSearch ringSearch = new RingSearch(m, graph);

                // all isolated cycles are relevant
                foreach (int[] isolated in ringSearch.Isolated())
                {
                    int[] path = Cycle(graph, isolated);
                }

                // compute the relevant cycles for each system
                foreach (int[] fused in ringSearch.Fused())
                {
                    int[][] subgraph = Subgraph(graph, fused);
                    RelevantCycles relevantOfSubgraph = new RelevantCycles(subgraph);

                    foreach (int[] path in relevantOfSubgraph.GetPaths())
                    {
                        // convert the sub graph vertices back to the super graph indices
                        for (int i = 0; i &lt; path.Length; i++)
                        {
                            path[i] = fused[path[i]];
                        }
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.RelevantCycles_Example.cs+GetPaths">
    <code>                RelevantCycles relevant = new RelevantCycles(ToAdjList(mol));

                // ensure the number is manageable
                if (relevant.Count() &lt; 100) {
                    foreach (int[] path in relevant.GetPaths())
                    {
                        // process the path
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs">
    <code>                IAtomContainer benzene = TestMoleculeFactory.MakeBenzene();

                IAtom c1 = benzene.Atoms[0];
                IAtom c4 = benzene.Atoms[3];

                // shortest paths from C1
                ShortestPaths sp = new ShortestPaths(benzene, c1);

                // number of paths from C1 to C4
                int nPaths = sp.GetNPathsTo(c4);

                // distance between C1 to C4
                int distance = sp.GetDistanceTo(c4);

                // reconstruct a path to the C4 - determined by storage order
                int[] path = sp.GetPathTo(c4);

                // reconstruct all paths
                int[][] paths = sp.GetPathsTo(c4);
                int[] org = paths[0];  // paths[0] == path
                int[] alt = paths[1];
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetPathTo_int">
    <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);

                // reconstruct first path
                int[] path = sp.GetPathTo(5);

                // check there is only one path
                if (sp.GetNPathsTo(5) == 1)
                {
                    path = sp.GetPathTo(5); // reconstruct the path
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetPathTo_IAtom">
    <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);
                IAtom end = benzene.Atoms[3];

                // reconstruct first path
                int[] path = sp.GetPathTo(end);

                // check there is only one path
                if (sp.GetNPathsTo(end) == 1)
                {
                    path = sp.GetPathTo(end); // reconstruct the path
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetPathsTo_int">
    <code>                int threshold = 20;
                ShortestPaths sp = new ShortestPaths(benzene, c1);

                // reconstruct shortest paths
                int[][] paths = sp.GetPathsTo(5);

                // only reconstruct shortest paths below a threshold
                if (sp.GetNPathsTo(5) &lt; threshold)
                {
                    int[][] path = sp.GetPathsTo(5); // reconstruct shortest paths
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetPathsTo_IAtom">
    <code>                int threshold = 20;
                ShortestPaths sp = new ShortestPaths(benzene, c1);
                IAtom end = benzene.Atoms[3];

                // reconstruct all shortest paths
                int[][] paths = sp.GetPathsTo(end);

                // only reconstruct shortest paths below a threshold
                if (sp.GetNPathsTo(end) &lt; threshold)
                {
                    paths = sp.GetPathsTo(end); // reconstruct shortest paths
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetAtomsTo_int">
    <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);

                // reconstruct a shortest path
                IAtom[] path = sp.GetAtomsTo(5);

                // ensure single shortest path
                if (sp.GetNPathsTo(5) == 1)
                {
                    path = sp.GetAtomsTo(5); // reconstruct shortest path
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetAtomsTo_IAtom">
    <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);
                IAtom end = benzene.Atoms[3];

                // reconstruct a shortest path
                IAtom[] path = sp.GetAtomsTo(end);

                // ensure single shortest path
                if (sp.GetNPathsTo(end) == 1)
                {
                    path = sp.GetAtomsTo(end); // reconstruct shortest path
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetNPathsTo_int">
    <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);

                sp.GetNPathsTo(5); // number of paths

                sp.GetNPathsTo(-1); // returns 0 - there are no paths
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetNPathsTo_IAtom">
    <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);
                IAtom end = benzene.Atoms[3];

                sp.GetNPathsTo(end); // number of paths

                sp.GetNPathsTo(null);           // returns 0 - there are no paths
                sp.GetNPathsTo(new Atom("C"));  // returns 0 - there are no paths
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetDistanceTo_int_1">
    <code>                IAtomContainer container = TestMoleculeFactory.MakeBenzene();
                IAtom c1 = container.Atoms[0];
                ShortestPaths sp = new ShortestPaths(container, c1); // start = 0

                int n = container.Atoms.Count;

                if (sp.GetDistanceTo(5) &lt; n)
                {
                    // these is a path from 0 to 5
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetDistanceTo_int_2">
    <code>                IAtomContainer container = TestMoleculeFactory.MakeBenzene();
                IAtom c1 = container.Atoms[0];
                ShortestPaths sp = new ShortestPaths(container, c1); // start = 0

                int[] path = sp.GetPathTo(5);
                
                 int start = path[0];
                 int end   = path[sp.GetDistanceTo(5)];                
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetDistanceTo_IAtom_1">
    <code>                 IAtomContainer container = TestMoleculeFactory.MakeBenzene();
                IAtom c1 = container.Atoms[0];
                ShortestPaths sp = new ShortestPaths(container, c1); // start atom
                IAtom end = container.Atoms[3];

                int n = container.Atoms.Count;
                
                 if( sp.GetDistanceTo(end) &lt; n) {
                     // these is a path from start to end
                 }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetDistanceTo_IAtom_2">
    <code>                 IAtomContainer container = TestMoleculeFactory.MakeBenzene();
                IAtom c1 = container.Atoms[0];
                ShortestPaths  sp = new ShortestPaths(container, c1); // start atom
                IAtom end = container.Atoms[3];

                IAtom[] atoms = sp.GetAtomsTo(end);
                Console.WriteLine(end == atoms[sp.GetDistanceTo(end)]); // true
</code>
  </Codes>
  <Codes id="NCDK.Groups.AtomDiscretePartitionRefiner_Example.cs+1">
    <code>                IAtomContainer ac = someMolecule; // get an atom container somehow
                AtomDiscretePartitionRefiner refiner = new AtomDiscretePartitionRefiner();
                PermutationGroup autG = refiner.GetAutomorphismGroup(ac);
                foreach (var automorphism in autG.GenerateAll())
                {
                    // do something with the permutation
                }
</code>
  </Codes>
  <Codes id="NCDK.Groups.AtomDiscretePartitionRefiner_Example.cs+2">
    <code>                IAtomContainer ac = someMolecule; // get an atom container somehow
                AtomDiscretePartitionRefiner refiner = new AtomDiscretePartitionRefiner();
                if (refiner.IsCanonical(ac))
                {
                    // do something with the atom container
                }
</code>
  </Codes>
  <Codes id="NCDK.Groups.AtomDiscretePartitionRefiner_Example.cs+3">
    <code>                AtomDiscretePartitionRefiner refiner = new AtomDiscretePartitionRefiner();
                refiner.Refine(ac);
                bool isCanon = refiner.IsCanonical();
                PermutationGroup autG = refiner.GetAutomorphismGroup();
</code>
  </Codes>
  <Codes id="NCDK.Groups.BondDiscretePartitionRefiner_Example.cs+1">
    <code>                IAtomContainer ac = someMolecule; // get an atom container somehow
                BondDiscretePartitionRefiner refiner = new BondDiscretePartitionRefiner();
                PermutationGroup autG = refiner.GetAutomorphismGroup(ac);
                foreach (var automorphism in autG.GenerateAll())
                {
                    // do something with the permutation
                }
</code>
  </Codes>
  <Codes id="NCDK.Groups.BondDiscretePartitionRefiner_Example.cs+2">
    <code>                IAtomContainer ac = someMolecule; // get an atom container somehow
                BondDiscretePartitionRefiner refiner = new BondDiscretePartitionRefiner();
                if (refiner.IsCanonical(ac))
                {
                     // do something with the atom container
                 }
</code>
  </Codes>
  <Codes id="NCDK.Groups.BondDiscretePartitionRefiner_Example.cs+3">
    <code>                BondDiscretePartitionRefiner refiner = new BondDiscretePartitionRefiner();
                refiner.Refine(ac);
                bool isCanon = refiner.IsCanonical();
                PermutationGroup autG = refiner.GetAutomorphismGroup();
</code>
  </Codes>
  <Codes id="NCDK.Hash.HashGeneratorMaker_Example.cs">
    <code>            // simple
            IMoleculeHashGenerator generator0 = new HashGeneratorMaker().Depth(16)
                                                                       .Elemental()
                                                                       .Molecular();

            // fast
            IMoleculeHashGenerator generator1 = new HashGeneratorMaker().Depth(8)
                                                                       .Elemental()
                                                                       .Isotopic()
                                                                       .Charged()
                                                                       .Orbital()
                                                                       .Molecular();
            // comprehensive
            IMoleculeHashGenerator generator2 = new HashGeneratorMaker().Depth(32)
                                                                       .Elemental()
                                                                       .Isotopic()
                                                                       .Charged()
                                                                       .Chiral()
                                                                       .Perturbed()
                                                                       .Molecular();
</code>
  </Codes>
  <Codes id="NCDK.IO.Iterator.IteratingMDLConformerReader_Example.cs">
    <code>                string filename = "/Users/rguha/conf2.sdf";
                using (var srm = new FileStream(filename, FileMode.Open))
                {
                    IteratingMDLConformerReader reader = new IteratingMDLConformerReader(srm, Default.ChemObjectBuilder.Instance);
                    foreach (var cc in reader)
                    {
                        // do something 
                    }
                }
                // do something with this set of conformers
</code>
  </Codes>
  <Codes id="NCDK.IO.Iterator.IteratingSDFReader_Example.cs">
    <code>                using (var srm = new FileStream("../zinc-structures/ZINC_subset3_3D_charged_wH_maxmin1000.sdf", FileMode.Open))
                {
                    IteratingSDFReader reader = new IteratingSDFReader(srm, Default.ChemObjectBuilder.Instance);
                    foreach (var molecule in reader)
                    {
                        // do something
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.IO.Setting.SettingManager_Example.cs">
    <code>                // create the manager and add a setting
                var manager = new SettingManager&lt;BooleanIOSetting&gt;();
                manager.Add(new BooleanIOSetting("Sample", IOSetting.Importance.Medium, "This is a sample?", "true"));

                // check the setting is present (case insensitive)
                if (manager.Has("sample"))
                {
                    // access requiring multiple lines of code
                    BooleanIOSetting setting = manager["sample"];
                    string v1 = setting.Setting;
                    // single line access (useful for conditional statements)
                    string v2 = manager["sample"].Setting;
                }
</code>
  </Codes>
  <Codes id="NCDK.IO.Setting.SettingManager_Example.cs+Add">
    <code>                var manager = new SettingManager&lt;BooleanIOSetting&gt;();
                BooleanIOSetting setting1 = manager.Add(new BooleanIOSetting("use.3d", importance, some, some));
                BooleanIOSetting setting2 = manager.Add(new BooleanIOSetting("use.3d", importance, some, some));

                // setting1 == setting2 and so changing a field in setting1 will also change the field
                // in setting2
</code>
  </Codes>
  <Codes id="NCDK.IO.Setting.SettingManager_Example.cs+get">
    <code>                var manager = new SettingManager&lt;BooleanIOSetting&gt;();
                manager.Add(new BooleanIOSetting("name", importance, some, some));

                BooleanIOSetting setting1 = manager["Name"]; // okay
                // OptionIOSetting setting2 = manager["Name"]; // failed to compile
</code>
  </Codes>
  <Codes id="NCDK.IO.CMLWriter_Example.cs">
    <code>                using (var output = new FileStream("molecule.cml", FileMode.Create))
                using (CMLWriter cmlwriter = new CMLWriter(output))
                {
                    cmlwriter.Write(molecule);
                }
</code>
  </Codes>
  <Codes id="NCDK.IO.FormatFactory_Example.cs">
    <code>                StringReader stringReader = new StringReader("&lt;molecule/&gt;");
                IChemFormat format = new FormatFactory().GuessFormat(stringReader);
</code>
  </Codes>
  <Codes id="NCDK.IO.MDLRXNWriter_Example.cs">
    <code>                using (var srm = new FileStream("output.mol", FileMode.Create))
                using (MDLRXNWriter writer = new MDLRXNWriter(srm))
                {
                    writer.Write(molecule);
                }
</code>
  </Codes>
  <Codes id="NCDK.IO.MDLV2000Writer_Example.cs">
    <code>                using (var srm = new FileStream("output.mol", FileMode.Create))
                using (MDLV2000Writer writer = new MDLV2000Writer(srm))
                {
                    writer.Write((IAtomContainer)molecule);
                }
</code>
  </Codes>
  <Codes id="NCDK.IO.MDLV2000Writer_Example.cs+listener">
    <code>                var customSettings = new NameValueCollection();
                customSettings["ForceWriteAs2DCoordinates"] = "true";
                PropertiesListener listener = new PropertiesListener(customSettings);
                writer.Listeners.Add(listener);
</code>
  </Codes>
  <Codes id="NCDK.IO.NCDKSourceCodeWriter_Example.cs">
    <code>                using (var stringWriter = new StringWriter())
                {
                    using (var writer = new NCDKSourceCodeWriter(stringWriter))
                    {
                        writer.Write(molecule);
                    }
                    Console.Out.Write(stringWriter.ToString());
                }
</code>
  </Codes>
  <Codes id="NCDK.IO.ReaderFactory_Example.cs">
    <code>            using (StringReader stringReader = new StringReader("&lt;molecule/&gt;"))
            using (var reader = new ReaderFactory().CreateReader(stringReader))
            {
                //
            }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.ComponentGrouping_Example.cs">
    <code>            // grouping is actually set by SMARTS parser but this shows how it's stored
            query.SetProperty(ComponentGrouping.Key, grouping);

            IAtomContainer target = someTarget;
            Pattern pattern = somePattern; // create pattern for query

            // filter for mappings which respect component grouping in the query
            var filter = new ComponentGrouping(query, target);
            pattern.MatchAll(target).Where(n =&gt; filter.Apply(n));
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+1">
    <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                Mappings mappings = Pattern.FindSubstructure(query).MatchAll(target);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+enum_mappings">
    <code>                foreach (int[] p in mappings)
                {
                    for (int i = 0; i &lt; p.Length; i++)
                    {
                        // query.Atoms[i] is mapped to target.Atoms[p[i]];
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+stereochemistry">
    <code>                foreach (int[] p in mappings.GetStereochemistry())
                {
                    // ...
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+unique_matches">
    <code>                foreach (int[] p in mappings.GetUniqueAtoms())
                {
                    // ...
                }

                foreach (int[] p in mappings.GetUniqueBonds())
                {
                    // ...
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+toarray">
    <code>                    int[][] ps = mappings.ToArray();
                    foreach (int[] p in ps)
                    {
                        // ...
                    }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+limit_matches">
    <code>                    // first ten matches
                    foreach (int[] p in mappings.Limit(10))
                    {
                        // ...
                    }

                    // first 10 unique matches
                    foreach (int[] p in mappings.GetUniqueAtoms().Limit(10))
                    {
                        // ...
                    }

                    // ensure we don't waste memory and only 'fix' up to 100 unique matches
                    int[][] ps = mappings.GetUniqueAtoms().Limit(100).ToArray();
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+all">
    <code>                // first 100 unique matches
                Mappings m1 = mappings.GetUniqueAtoms().Limit(100);

                // unique matches in the first 100 matches
                Mappings m2 = mappings.Limit(100).GetUniqueAtoms();

                // first 10 unique matches in the first 100 matches
                Mappings m3 = mappings.Limit(100).GetUniqueAtoms().Limit(10);

                // number of unique atom matches
                int n1 = mappings.CountUnique();

                // number of unique atom matches with correct stereochemistry
                int n2 = mappings.GetStereochemistry().CountUnique();
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+Filter">
    <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                // obtain only the mappings where the first atom in the query is
                // mapped to the first atom in the target
                Mappings mappings = Pattern.FindSubstructure(query)
                    .MatchAll(target)
                    .Filter(input =&gt; input[0] == 0);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+GetMapping">
    <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                Mappings mappings = Pattern.FindSubstructure(query).MatchAll(target);
                // a string that indicates the mapping of atom elements and numbers
                IEnumerable&lt;string&gt; strs = mappings.GetMapping(
                    input =&gt;
                    {
                        StringBuilder sb = new StringBuilder();
                        for (int i = 0; i &lt; input.Length; i++)
                        {
                            if (i &gt; 0) sb.Append(", ");
                            sb.Append(query.Atoms[i])
                               .Append(i + 1)
                               .Append(" -&gt; ")
                               .Append(target.Atoms[input[i]])
                               .Append(input[i] + 1);
                        }
                        return sb.ToString();
                    });
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToArray1">
    <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                Pattern pat = Pattern.FindSubstructure(query);

                // lazily iterator
                foreach (int[] mapping in pat.MatchAll(target))
                {
                    // logic...
                }

                int[][] mappings = pat.MatchAll(target).ToArray();

                // same as lazy iterator but we now can refer to and parse 'mappings'
                // to other methods without regenerating the graph match
                foreach (int[] mapping in mappings)
                {
                    // logic...
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToArray2">
    <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                Pattern pat = Pattern.FindSubstructure(query);

                // array of the first 5 unique atom mappings
                int[][] mappings = pat.MatchAll(target)
                                      .GetUniqueAtoms()
                                      .Limit(5)
                                      .ToArray();
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToAtomMap">
    <code>                foreach (IDictionary&lt;IAtom, IAtom&gt; map in mappings.ToAtomMap())
                {
                    foreach (KeyValuePair&lt;IAtom, IAtom&gt; e in map)
                    {
                        IAtom queryAtom = e.Key;
                        IAtom targetAtom = e.Value;
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToBondMap">
    <code>                foreach (IDictionary&lt;IBond, IBond&gt; map in mappings.ToBondMap())
                {
                    foreach (KeyValuePair&lt;IBond, IBond&gt; e in map)
                    {
                        IBond queryBond = e.Key;
                        IBond targetBond = e.Value;
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToAtomBondMap">
    <code>                foreach (var map in mappings.ToAtomBondMap())
                {
                    foreach (var e in map)
                    {
                        IChemObject queryObj = e.Key;
                        IChemObject targetObj = e.Value;
                    }
                    IAtom matchedAtom = (IAtom)map[query.Atoms[i]];
                    IBond matchedBond = (IBond)map[query.Bonds[i]];
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToChemObjects">
    <code>                foreach (var obj in mappings.ToChemObjects())
                {
                    if (obj is IAtom)
                    {
                        // this atom was 'hit' by the pattern
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToSubstructures">
    <code>                IAtomContainer target = targetStructure;
                Mappings mappings = someMappings;
                foreach (var mol in mappings.ToSubstructures())
                {
                    foreach (var atom in mol.Atoms)
                        target.Contains(atom); // always true
                    foreach (var atom in target.Atoms)
                        mol.Contains(atom); // not always true
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+AtLeast">
    <code>                Mappings mappings = someMappings;

                if (mappings.AtLeast(5))
                {
                    // set bit flag etc.
                }

                // are the at least 5 unique matches?
                if (mappings.GetUniqueAtoms().AtLeast(5))
                {
                    // set bit etc.
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Pattern_Example.cs+Match">
    <code>                Pattern pattern = createPattern; // create pattern
                foreach (var m in ms)
                {
                    int[] mapping = pattern.Match(m);
                    if (mapping.Length &gt; 0)
                    {
                        // found mapping!
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Pattern_Example.cs+Matches">
    <code>                Pattern pattern = createPattern; // create pattern
                foreach (var m in ms)
                {
                    if (pattern.Matches(m))
                    {
                        // found mapping!
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Pattern_Example.cs+MatchAll1">
    <code>                Pattern pattern = Pattern.FindSubstructure(query);
                foreach (var m in ms)
                {
                    foreach (int[] mapping in pattern.MatchAll(m))
                    {
                        // found mapping
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Pattern_Example.cs+MatchAll2">
    <code>                // find only the first 5 mappings and store them in an array
                Pattern pattern = Pattern.FindSubstructure(query);
                int[][] mappings = pattern.MatchAll(target)
                                          .Limit(5)
                                          .ToArray();
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Ullmann_Example.cs+1">
    <code>                IAtomContainer query = queryStructure;
                Pattern pattern = Ullmann.FindSubstructure(query);

                int hits = 0;
                foreach (var m in ms)
                    if (pattern.Matches(m))
                        hits++;
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Ullmann_Example.cs+2">
    <code>                IAtomContainer query = queryStructure;
                Pattern pattern = Ullmann.FindSubstructure(query);

                int hits = 0;
                foreach (var m in ms)
                {
                    int[] match = pattern.Match(m);
                    if (match.Length &gt; 0)
                        hits++;
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.UniversalIsomorphismTester_Example.cs">
    <code>            SmilesParser sp = new SmilesParser(Default.ChemObjectBuilder.Instance);
            IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C"); // acetic acid anhydride
            IAtomContainer SMILESquery = sp.ParseSmiles("CC"); // ethylene
            IQueryAtomContainer query = QueryAtomContainerCreator.CreateBasicQueryContainer(SMILESquery);
            bool isSubstructure = universalIsomorphismTester.IsSubgraph(atomContainer, query);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.VentoFoggia_Example.cs+1">
    <code>                IAtomContainer query = queryStructure;
                Pattern pattern = VentoFoggia.FindSubstructure(query);

                int hits = 0;
                foreach (var m in ms)
                    if (pattern.Matches(m))
                        hits++;
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.VentoFoggia_Example.cs+2">
    <code>                IAtomContainer query = queryStructure;
                Pattern pattern = VentoFoggia.FindSubstructure(query);

                int hits = 0;
                foreach (var m in ms)
                {
                    int[] match = pattern.Match(m);
                    if (match.Length &gt; 0)
                        hits++;
                }
</code>
  </Codes>
  <Codes id="NCDK.Layout.HydrogenPlacer_Example.cs">
    <code>            IAtomContainer container = TestMoleculeFactory.MakeAlphaPinene();
            HydrogenPlacer hydrogenPlacer = new HydrogenPlacer();
            hydrogenPlacer.PlaceHydrogens2D(container, 1.5);
</code>
  </Codes>
  <Codes id="NCDK.Layout.StructureDiagramGenerator_Example.cs">
    <code>            StructureDiagramGenerator sdg = new StructureDiagramGenerator();
             sdg.Molecule = someMolecule;
             sdg.GenerateCoordinates();
            IAtomContainer layedOutMol = sdg.Molecule;
</code>
  </Codes>
  <Codes id="NCDK.Modeling.Builder3D.ModelBuilder3D_Example.cs">
    <code>            ModelBuilder3D mb3d = ModelBuilder3D.GetInstance(Default.ChemObjectBuilder.Instance);
            IAtomContainer molecule = mb3d.Generate3DCoordinates(mol, false);
</code>
  </Codes>
  <Codes id="NCDK.Pharmacophore.PharmacophoreMatcher_Example.cs">
    <code>            QueryAtomContainer query = new QueryAtomContainer(Default.ChemObjectBuilder.Instance);

            PharmacophoreQueryAtom o = new PharmacophoreQueryAtom("D", "[OX1]");
            PharmacophoreQueryAtom n1 = new PharmacophoreQueryAtom("A", "[N]");
            PharmacophoreQueryAtom n2 = new PharmacophoreQueryAtom("A", "[N]");

            query.Atoms.Add(o);
            query.Atoms.Add(n1);
            query.Atoms.Add(n2);

            PharmacophoreQueryBond b1 = new PharmacophoreQueryBond(o, n1, 4.0, 4.5);
            PharmacophoreQueryBond b2 = new PharmacophoreQueryBond(o, n2, 4.0, 5.0);
            PharmacophoreQueryBond b3 = new PharmacophoreQueryBond(n1, n2, 5.4, 5.8);

            query.Bonds.Add(b1);
            query.Bonds.Add(b2);
            query.Bonds.Add(b3);

            string filename = "/Users/rguha/pcore1.sdf";
            using (var srm = new FileStream(filename, FileMode.Open))
            {
                foreach (var conformers in new IteratingMDLConformerReader(srm, Default.ChemObjectBuilder.Instance))
                {
                    bool firstTime = true;
                    foreach (var conf in conformers)
                    {
                        bool status;
                        if (firstTime)
                        {
                            status = matcher.Matches(conf, true);
                            firstTime = false;
                        }
                        else status = matcher.Matches(conf, false);
                        if (status)
                        {
                            // OK, matched. Do something
                        }
                    }
</code>
  </Codes>
  <Codes id="NCDK.Pharmacophore.PharmacophoreUtils_Example.cs+ReadPharmacophoreDefinitions">
    <code>            using (var srm = new FileStream("mydefs.xml", FileMode.Open))
            {
                IList&lt;PharmacophoreQuery&gt; defs = PharmacophoreUtils.ReadPharmacophoreDefinitions(srm);
                Console.Out.WriteLine("Number of definitions = " + defs.Count);
                for (int i = 0; i &lt; defs.Count; i++) {
                    Console.Out.WriteLine($"Desc: {defs[i].GetProperty&lt;string&gt;("description")}");
                }
            }
</code>
  </Codes>
  <Codes id="NCDK.QSAR.DescriptorEngine_Example.cs">
    <code>                IAtomContainer someMolecule = TestMoleculeFactory.MakeAlphaPinene();
                // ...
                DescriptorEngine descriptorEngine = DescriptorEngine.Create&lt;IMolecularDescriptor&gt;(null);
                descriptorEngine.Process(someMolecule);
</code>
  </Codes>
  <Codes id="NCDK.QSAR.DescriptorEngine_Example.cs+ctor">
    <code>                var classNames = DescriptorEngine.GetDescriptorClassNameByPackage("NCDK.QSRA.Descriptors.Moleculars", null);
                DescriptorEngine engine = new DescriptorEngine(classNames, Default.ChemObjectBuilder.Instance);
                var instances = engine.InstantiateDescriptors(classNames);
                var specs = engine.InitializeSpecifications(instances);
                engine.SetDescriptorInstances(instances);
                engine.SetDescriptorSpecifications(specs);

                engine.Process(someAtomContainer);
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.AllRingsFinder_Example.cs">
    <code>                AllRingsFinder arf = new AllRingsFinder();
                foreach (var m in ms)
                {
                    try
                    {
                        IRingSet rs = arf.FindAllRings(m);
                    }
                    catch (CDKException)
                    {
                        // molecule was too complex, handle error
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.AllRingsFinder_Example.cs+UsingThreshold">
    <code>                // using static NCDK.RingSearches.AllRingsFinder.Threshold;
                AllRingsFinder arf = AllRingsFinder.UsingThreshold(PubChem_99);
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.RingSearch_Example.cs">
    <code>                // construct the search for a given molecule, if an adjacency list
                // representation (int[][]) is available this can be passed to the
                // constructor for improved performance
                IAtomContainer container = TestMoleculeFactory.MakeAlphaPinene();
                RingSearch ringSearch = new RingSearch(container);

                // indices of cyclic vertices
                int[] cyclic = ringSearch.Cyclic();

                // iterate over fused systems (atom indices)
                foreach (int[] fused in ringSearch.Fused())
                {
                    // ...
                }

                // iterate over isolated rings (atom indices)
                foreach (int[] isolated in ringSearch.Isolated())
                {
                    // ...
                }

                // convenience methods for getting the fragments
                IAtomContainer fragments = ringSearch.RingFragments();

                foreach (IAtomContainer fragment in ringSearch.FusedRingFragments())
                {
                    // ...
                }
                foreach (IAtomContainer fragment in ringSearch.IsolatedRingFragments())
                {
                    // ...
                }
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.RingSearch_Example.cs+Cyclic">
    <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                RingSearch ringSearch = new RingSearch(mol);
                foreach (var atom in mol.Atoms)
                {
                    if (ringSearch.Cyclic(atom))
                    {
                        // ...
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.RingSearch_Example.cs+Cyclic_int">
    <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                RingSearch tester = new RingSearch(mol);

                int n = mol.Atoms.Count;
                for (int i = 0; i &lt; n; i++)
                {
                    if (tester.Cyclic(i))
                    {
                        // ...
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.RingSearch_Example.cs+Isolated">
    <code>                IAtomContainer biphenyl = TestMoleculeFactory.MakeBiphenyl();
                RingSearch ringSearch = new RingSearch(biphenyl);

                int[][] isolated = ringSearch.Isolated();
                Console.WriteLine(isolated.Length); // 2 isolated rings in biphenyl
                Console.WriteLine(isolated[0].Length); // 6 vertices in one benzene
                Console.WriteLine(isolated[1].Length); // 6 vertices in the other benzene
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.RingSearch_Example.cs+Fused">
    <code>                IAtomContainer mol = new Smiles.SmilesParser(Default.ChemObjectBuilder.Instance).ParseSmiles("c1cc(cc2cc(ccc12)C3C4CC34)C6CC5CCC6(C5)");
                RingSearch ringSearch = new RingSearch(mol);
                
                int[][] fused = ringSearch.Fused();
                Console.WriteLine(fused.Length); // e.g. 3 separate fused ring systems
                Console.WriteLine(fused[0].Length); // e.g. 10 vertices in the first system
                Console.WriteLine(fused[1].Length); // e.g. 4 vertices in the second system
                Console.WriteLine(fused[2].Length); // e.g. 7 vertices in the third system
</code>
  </Codes>
  <Codes id="NCDK.Signature.MoleculeSignature_Example.cs">
    <code>             IAtomContainer diamantane = TestMoleculeFactory.MakeBenzene();
             MoleculeSignature moleculeSignature = new MoleculeSignature(diamantane);
             string canonicalSignature = moleculeSignature.ToCanonicalString();
            
             // to get the orbits of this molecule
            IList&lt;Orbit&gt; orbits = moleculeSignature.CalculateOrbits();
            
             // and to get the height-2 signature string of just atom 5:
             string hSignatureForAtom5 = moleculeSignature.SignatureStringForVertex(5, 2);
</code>
  </Codes>
  <Codes id="NCDK.Similarity.Tanimoto_Example.cs+1">
    <code>            BitArray fingerprint1 = fingerprinter.GetBitFingerprint(molecule1).AsBitSet();
            BitArray fingerprint2 = fingerprinter.GetBitFingerprint(molecule2).AsBitSet();
            double tanimoto_coefficient = Tanimoto.Calculate(fingerprint1, fingerprint2);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.Parser.SMARTSParser_Example.cs+1">
    <code>            SmilesParser sp = new SmilesParser(Silent.ChemObjectBuilder.Instance);
             IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C");
             QueryAtomContainer query = SMARTSParser.Parse("C*C", Silent.ChemObjectBuilder.Instance);
             bool queryMatch = universalIsomorphismTester.IsSubgraph(atomContainer, query);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.Parser.SMARTSParser_Example.cs+2">
    <code>             SMARTSParser parser = new SMARTSParser(new StringReader("C*C"));
             ASTStart start = parser.Start();
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor_Example.cs+1">
    <code>             SMARTSParser parser = new SMARTSParser(new StringReader("C*C"));
             ASTStart ast = parser.Start();
             SmartsQueryVisitor visitor = new SmartsQueryVisitor(Silent.ChemObjectBuilder.Instance);
            QueryAtomContainer query = (QueryAtomContainer)visitor.Visit(ast, null);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.SmartsPattern_Example.cs+1">
    <code>                Pattern ptrn = SmartsPattern.Create("O[C@?H](C)CC", Default.ChemObjectBuilder.Instance);

                foreach (var ac in acs)
                {
                    if (ptrn.Matches(ac))
                    {
                        // 'ac' contains the pattern
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.SmartsPattern_Example.cs+2">
    <code>                Pattern ptrn = SmartsPattern.Create("O[C@?H](C)CC", Default.ChemObjectBuilder.Instance);

                foreach (var ac in acs)
                {
                    nUniqueHits += ptrn.MatchAll(ac).CountUnique();
                }
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.SmartsPattern_Example.cs+MatchAll">
    <code>                 Pattern ptrn = SmartsPattern.Create("O[C@?H](C)CC", Default.ChemObjectBuilder.Instance);
                 int nUniqueHits = 0;
                
                 foreach (var ac in acs) {
                   nUniqueHits += ptrn.MatchAll(ac).CountUnique();
                 }
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.SMARTSQueryTool_Example.cs">
    <code>                SmilesParser sp = new SmilesParser(Default.ChemObjectBuilder.Instance);
                IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C");
                SMARTSQueryTool querytool = new SMARTSQueryTool("O=CO", Silent.ChemObjectBuilder.Instance);
                bool status = querytool.Matches(atomContainer);
                if (status)
                {
                    int nmatch = querytool.MatchesCount;
                    IList&lt;IList&lt;int&gt;&gt; mappings = querytool.GetMatchingAtoms();
                    for (int i = 0; i &lt; nmatch; i++)
                    {
                        IList&lt;int&gt; atomIndices = mappings[i];
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.SMARTSQueryTool_Example.cs+SetAromaticity">
    <code>                SMARTSQueryTool sqt = new SMARTSQueryTool(someSmartsPattern, Default.ChemObjectBuilder.Instance);
                sqt.SetAromaticity(new Aromaticity(ElectronDonation.CDKModel, Cycles.CDKAromaticSetFinder));
                foreach (var molecule in molecules)
                {
                    // CDK Aromatic model needs atom types
                    AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(molecule);
                    sqt.Matches(molecule);
                }
</code>
  </Codes>
  <Codes id="NCDK.Smiles.CDKToBeam_Example.cs">
    <code>using NCDK.Templates;

namespace NCDK.Smiles
{
    class CDKToBeam_Example
    {
        void Main()
        {
            IAtomContainer m = TestMoleculeFactory.MakeBenzene();

            // converter is thread-safe and can be used by multiple threads
            CDKToBeam c2g = new CDKToBeam();
            Beam.Graph g = c2g.ToBeamGraph(m);

            // get the SMILES notation from the Beam graph
            string smi = g.ToSmiles();
        }
    }
}
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+1">
    <code>                    IAtomContainer ethanol = TestMoleculeFactory.MakeEthanol();

                    sg = SmilesGenerator.Generic();
                    smi = sg.Create(ethanol); // CCO or OCC

                    sg = SmilesGenerator.Unique();
                    smi = sg.Create(ethanol); // only CCO
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+2">
    <code>                    IAtomContainer benzene = TestMoleculeFactory.MakeBenzene();

                    // with no flags set the output is always kekule
                    sg = SmilesGenerator.Generic();
                    smi = sg.Create(benzene); // C1=CC=CC=C1

                    sg = SmilesGenerator.Generic().Aromatic();
                    smi = sg.Create(ethanol); // C1=CC=CC=C1

                    foreach (var a in benzene.Atoms)
                        a.IsAromatic = true;
                    foreach (var b in benzene.Bonds)
                        b.IsAromatic = true;

                    // with flags set, the aromatic generator encodes this information
                    sg = SmilesGenerator.Generic();
                    smi = sg.Create(benzene); // C1=CC=CC=C1

                    sg = SmilesGenerator.Generic()
                                                             .Aromatic();
                    smi = sg.Create(ethanol); // c1ccccc1
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+3">
    <code>                    // see CDKConstants for property key
                    benzene.Atoms[3].SetProperty(CDKPropertyName.AtomAtomMapping, 42);

                    sg = SmilesGenerator.Generic();
                    smi = sg.Create(benzene); // C1=CC=CC=C1

                    sg = SmilesGenerator.Generic().WithAtomClasses();
                    smi = sg.Create(ethanol); // C1=CC=[CH:42]C=C1
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+4">
    <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                SmilesGenerator sg = SmilesGenerator.Generic();

                int n = mol.Atoms.Count;
                int[] order = new int[n];

                // the order array is filled up as the SMILES is generated
                string smi = sg.Create(mol, order);

                // load the coordinates array such that they are in the order the atoms
                // are read when parsing the SMILES
                Vector2[] coords = new Vector2[mol.Atoms.Count];
                for (int i = 0; i &lt; coords.Length; i++)
                    coords[order[i]] = mol.Atoms[i].Point2D.Value;

                // SMILES string suffixed by the coordinates
                string smi2d = smi + " " + Arrays.ToJavaString(coords);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+Aromatic">
    <code>                IAtomContainer container = TestMoleculeFactory.MakeAlphaPinene();
                SmilesGenerator smilesGen = SmilesGenerator.Unique().Aromatic();
                smilesGen.CreateSMILES(container);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+WithAtomClasses">
    <code>                IAtomContainer container = TestMoleculeFactory.MakeAlphaPinene();
                SmilesGenerator smilesGen = SmilesGenerator.Unique().WithAtomClasses();
                smilesGen.CreateSMILES(container); // C[CH2:4]O second atom has class = 4
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs">
    <code>                 IAtomContainer  mol = TestMoleculeFactory.MakeAlphaPinene();
                SmilesGenerator sg  = SmilesGenerator.Generic();
                
                 int   n     = mol.Atoms.Count;
                 int[] order = new int[n];
                
                 // the order array is filled up as the SMILES is generated
                 string smi = sg.Create(mol, order);
                
                 // load the coordinates array such that they are in the order the atoms
                 // are read when parsing the SMILES
                 Vector2[] coords = new Vector2[mol.Atoms.Count];
                 for (int i = 0; i &lt; coords.Length; i++)
                     coords[order[i]] = mol.Atoms[i].Point2D.Value;
                
                 // SMILES string suffixed by the coordinates
                 string smi2d = smi + " " + Arrays.ToJavaString(coords);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesParser_Example.cs+1">
    <code>                SmilesParser sp = new SmilesParser(Silent.ChemObjectBuilder.Instance);
                IAtomContainer m = sp.ParseSmiles("c1[cH:5]cccc1");
                var c1 = m.Atoms[1].GetProperty&lt;int&gt;(CDKPropertyName.AtomAtomMapping); // 5
                var c2 = m.Atoms[2].GetProperty&lt;int&gt;(CDKPropertyName.AtomAtomMapping); // null
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesParser_Example.cs+2">
    <code>                SmilesParser sp = new SmilesParser(Silent.ChemObjectBuilder.Instance);
                IAtomContainer m = sp.ParseSmiles("c1[cH:5]cccc1");
                var c1 = m.Atoms[1].GetProperty&lt;int&gt;(CDKPropertyName.AtomAtomMapping); // 5
                var c2 = m.Atoms[2].GetProperty&lt;int&gt;(CDKPropertyName.AtomAtomMapping); // null
</code>
  </Codes>
  <Codes id="NCDK.SMSD.Algorithms.RGraph.CDKMCS_Example.cs">
    <code>            SmilesParser sp = new SmilesParser(Default.ChemObjectBuilder.Instance);
            IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C"); // acetic acid anhydride
            IAtomContainer SMILESquery = sp.ParseSmiles("CC"); // acetic acid anhydride
            IQueryAtomContainer query = QueryAtomContainerCreator.CreateBasicQueryContainer(SMILESquery);
            bool isSubstructure = CDKMCS.IsSubgraph(atomContainer, query, true);
</code>
  </Codes>
  <Codes id="NCDK.SMSD.Isomorphism_Example.cs+1">
    <code>                SmilesParser sp = new SmilesParser(Default.ChemObjectBuilder.Instance);
                // Benzene
                IAtomContainer A1 = sp.ParseSmiles("C1=CC=CC=C1");
                // Napthalene
                IAtomContainer A2 = sp.ParseSmiles("C1=CC2=C(C=C1)C=CC=C2");
                //Turbo mode search
                //Bond Sensitive is set true
                Isomorphism comparison = new Isomorphism(Algorithm.SubStructure, true);
                // set molecules, remove hydrogens, clean and configure molecule
                comparison.Init(A1, A2, true, true);
                // set chemical filter true
                comparison.SetChemFilters(false, false, false);
                if (comparison.IsSubgraph())
                {
                    //Get similarity score
                    Console.Out.WriteLine("Tanimoto coefficient:  " + comparison.GetTanimotoSimilarity());
                    Console.Out.WriteLine("A1 is a subgraph of A2:  " + comparison.IsSubgraph());
                    //Get Modified AtomContainer
                    IAtomContainer Mol1 = comparison.ReactantMolecule;
                    IAtomContainer Mol2 = comparison.ProductMolecule;
                    // Print the mapping between molecules
                    Console.Out.WriteLine(" Mappings: ");
                    foreach (var mapping in comparison.GetFirstMapping())
                    {
                        Console.Out.WriteLine((mapping.Key + 1) + " " + (mapping.Value + 1));

                        IAtom eAtom = Mol1.Atoms[mapping.Key];
                        IAtom pAtom = Mol2.Atoms[mapping.Value];
                        Console.Out.WriteLine(eAtom.Symbol + " " + pAtom.Symbol);
                    }
                    Console.Out.WriteLine("");
                }
</code>
  </Codes>
  <Codes id="NCDK.SMSD.Isomorphism_Example.cs+2">
    <code>                SmilesParser sp = new SmilesParser(Default.ChemObjectBuilder.Instance);
                // Benzene
                IAtomContainer A1 = sp.ParseSmiles("C1=CC=CC=C1");
                // Napthalene
                IAtomContainer A2 = sp.ParseSmiles("C1=CC2=C(C=C1)C=CC=C2");
                //{ 0: Default Isomorphism Algorithm, 1: MCSPlus Algorithm, 2: VFLibMCS Algorithm, 3: CDKMCS Algorithm}
                //Bond Sensitive is set true
                Isomorphism comparison = new Isomorphism(Algorithm.Default, true);
                // set molecules, remove hydrogens, clean and configure molecule
                comparison.Init(A1, A2, true, true);
                // set chemical filter true
                comparison.SetChemFilters(true, true, true);

                //Get similarity score
                Console.Out.WriteLine("Tanimoto coefficient:  " + comparison.GetTanimotoSimilarity());
                Console.Out.WriteLine("A1 is a subgraph of A2:  " + comparison.IsSubgraph());
                //Get Modified AtomContainer
                IAtomContainer Mol1 = comparison.ReactantMolecule;
                IAtomContainer Mol2 = comparison.ProductMolecule;
                // Print the mapping between molecules
                Console.Out.WriteLine(" Mappings: ");
                foreach (var mapping in comparison.GetFirstMapping())
                {
                    Console.Out.WriteLine((mapping.Key + 1) + " " + (mapping.Value + 1));

                    IAtom eAtom = Mol1.Atoms[mapping.Key];
                    IAtom pAtom = Mol2.Atoms[mapping.Value];
                    Console.Out.WriteLine(eAtom.Symbol + " " + pAtom.Symbol);
                }
                Console.Out.WriteLine("");
</code>
  </Codes>
  <Codes id="NCDK.Stereo.Stereocenters_Example.cs+Of">
    <code>            IAtomContainer container = someContainer;
            Stereocenters centers = Stereocenters.Of(container);
            for (int i = 0; i &lt; container.Atoms.Count; i++)
            {
                if (centers.IsStereocenter(i))
                {

                }
            }
</code>
  </Codes>
  <Codes id="NCDK.Stereo.StereoElementFactory_Example.cs">
    <code>                IAtomContainer container = someMolecule;
                StereoElementFactory stereo = StereoElementFactory.Using2DCoordinates(container).InterpretProjections(Projection.Haworth);

                // set the elements replacing any existing elements (recommended)
                container.SetStereoElements(stereo.CreateAll());

                // adding elements individually is no recommended as the AtomContainer
                // does not check for duplicate or contradicting elements
                foreach (var element in stereo.CreateAll())
                    container.StereoElements.Add(element); // bad, there may already be elements
</code>
  </Codes>
  <Codes id="NCDK.Stereo.StereoElementFactory_Example.cs+CreateTetrahedral_int">
    <code>                StereoElementFactory factory = someFactory; // 2D/3D
                IAtomContainer container = someMolecule; // container

                for (int v = 0; v &lt; container.Atoms.Count; v++)
                {
                    // ... verify v is a stereo atom ...
                    ITetrahedralChirality element = factory.CreateTetrahedral(v, null);
                    if (element != null)
                        container.StereoElements.Add(element);
                }
</code>
  </Codes>
  <Codes id="NCDK.Stereo.StereoElementFactory_Example.cs+CreateTetrahedral_IAtom">
    <code>                StereoElementFactory factory = someFactory; // 2D/3D
                IAtomContainer container = someMolecule; // container

                foreach (var atom in container.Atoms)
                {
                    // ... verify atom is a stereo atom ...
                    ITetrahedralChirality element = factory.CreateTetrahedral(atom, null);
                    if (element != null)
                        container.StereoElements.Add(element);
                }
</code>
  </Codes>
  <Codes id="NCDK.Stereo.StereoElementFactory_Example.cs+CreateGeometric_IBond">
    <code>                StereoElementFactory factory = someFactory; // 2D/3D
                IAtomContainer container = someMolecule; // container

                foreach (var bond in container.Bonds)
                {
                    if (bond.Order != BondOrder.Double)
                        continue;
                    // ... verify bond is a stereo bond...
                    IDoubleBondStereochemistry element = factory.CreateGeometric(bond, null);
                    if (element != null)
                        container.StereoElements.Add(element);
                }
</code>
  </Codes>
  <Codes id="NCDK.Stereo.StereoElementFactory_Example.cs+CreateExtendedTetrahedral">
    <code>                StereoElementFactory factory = someFactory; // 2D/3D
                IAtomContainer container = someMolecule; // container

                for (int v = 0; v &lt; container.Atoms.Count; v++)
                {
                    // ... verify v is a stereo atom ...
                    ExtendedTetrahedral element = factory.CreateExtendedTetrahedral(v, null);
                    if (element != null)
                        container.StereoElements.Add(element);
                }
</code>
  </Codes>
  <Codes id="NCDK.Stereo.StereoElementFactory_Example.cs+InterpretProjections">
    <code>                StereoElementFactory factory =
                    StereoElementFactory.Using2DCoordinates(container)
                        .InterpretProjections(Projection.Fischer, Projection.Haworth);
</code>
  </Codes>
  <Codes id="NCDK.Tools.AtomContainerManipulator_Example.cs+1">
    <code>                AtomContainerManipulator.ReplaceAtomByAtom(container, atom1, atom2);
</code>
  </Codes>
  <Codes id="NCDK.Tools.AtomContainerManipulator_Example.cs+SetSingleOrDoubleFlags">
    <code>            SmilesParser parser = new SmilesParser(Default.ChemObjectBuilder.Instance);
            parser.IsPreservingAromaticity = true;

            IAtomContainer biphenyl = parser.ParseSmiles("c1cccc(c1)c1ccccc1");

            AtomContainerManipulator.SetSingleOrDoubleFlags(biphenyl);
</code>
  </Codes>
  <Codes id="NCDK.Tools.CDKHydrogenAdder_Example.cs+1">
    <code>                IAtomContainer methane = new AtomContainer();
                IAtom carbon = new Atom("C");
                methane.Atoms.Add(carbon);
                CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.GetInstance(methane.Builder);
                foreach (var atom in methane.Atoms)
                {
                    IAtomType type = matcher.FindMatchingAtomType(methane, atom);
                    AtomTypeManipulator.Configure(atom, type);
                }
                CDKHydrogenAdder adder = CDKHydrogenAdder.GetInstance(methane.Builder);
                adder.AddImplicitHydrogens(methane);
</code>
  </Codes>
  <Codes id="NCDK.Tools.CDKHydrogenAdder_Example.cs+2">
    <code>                IAtomContainer ethane = new AtomContainer();
                IAtom carbon1 = new Atom("C");
                IAtom carbon2 = new Atom("C");
                ethane.Atoms.Add(carbon1);
                ethane.Atoms.Add(carbon2);
                CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.GetInstance(ethane.Builder);
                IAtomType type = matcher.FindMatchingAtomType(ethane, carbon1);
                AtomTypeManipulator.Configure(carbon1, type);
                CDKHydrogenAdder adder = CDKHydrogenAdder.GetInstance(ethane.Builder);
                adder.AddImplicitHydrogens(ethane, carbon1);
</code>
  </Codes>
  <Codes id="NCDK.Tools.DataFeatures_Example.cs+1">
    <code>            int features = new XYZFormat().SupportedDataFeatures;
            bool has3DCoords = (features &amp; HAS_3D_COORDINATES) == HAS_3D_COORDINATES;
</code>
  </Codes>
  <Codes id="NCDK.Tools.StructureResonanceGenerator_Example.cs+1">
    <code>            StructureResonanceGenerator sRG = new StructureResonanceGenerator();
            IAtomContainerSet&lt;IAtomContainer&gt; setOf = sRG.GetContainers(molecule);
</code>
  </Codes>
  <Codes id="NCDK.Tools.StructureResonanceGenerator_Example.cs+2">
    <code>            molecule.Atoms[0].IsReactiveCenter = true;
</code>
  </Codes>
  <Codes id="NCDK.ConformerContainer_Example.cs">
    <code>            var reader = new IteratingMDLConformerReader(
                new FileStream(filename, FileMode.Open),
                Default.ChemObjectBuilder.Instance);
            foreach (ConformerContainer cc in reader)
            {
                foreach (var conformer in cc)
                {
                    // do something with each conformer
                }
            }
</code>
  </Codes>
  <Codes id="NCDK.IAtomContainer_Example.cs">
    <code>            foreach (var bond in atomContainer.Bonds)
            {
                // do something
            }
</code>
  </Codes>
  <Codes id="NCDK.ISingleElectron_Example.cs">
    <code>                AtomContainer radical = new AtomContainer();
                Atom carbon = new Atom("C");
                carbon.ImplicitHydrogenCount = 3;
                radical.AddElectronContainer(new SingleElectron(carbon));
</code>
  </Codes>
  <Codes id="NCDK.Property_Example.cs">
    <code>using NCDK.Default;
using System;

namespace NCDK
{
    class Property_Example
    {
        static void Main(string[] args)
        {
            IAtom atom = new Atom("C");
            atom.SetProperty("number", 1); // set an integer property
            {
                // access the property and cast to an int
                int number = atom.GetProperty&lt;int&gt;("number");
            }
            {
                // the type cannot be checked and so...
                try
                {
                    string number = atom.GetProperty&lt;string&gt;("number");
                }
                catch (InvalidCastException)
                {
                    Console.WriteLine($"{nameof(InvalidCastException)} is thrown");
                }
            }
        }
    }
}
</code>
  </Codes>
</Comments>

