/* Generated By:JJTree&JavaCC: Do not edit this line. SMARTSParser.java */
/* Copyright (C) 2004-2007  The Chemistry Development Kit (CDK) project
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 * (or see http://www.gnu.org/copyleft/lesser.html)
 */
using NCDK.Isomorphisms.Matchers;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using static NCDK.Smiles.SMARTS.Parser.SMARTSParserTreeConstants;
using static NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants;

namespace NCDK.Smiles.SMARTS.Parser
{
    /// <summary>
    /// This parser implements a nearly complete subset of the SMARTS syntax as defined on
    /// <see href="http://www.daylight.com/dayhtml/doc/theory/theory.smarts.html">the Daylight website</see>. 
    /// </summary>
    /// <example>
    /// <para>
    /// Example code using SMARTS substructure search looks like:
    /// <include file='IncludeExamples.xml' path='Comments/Codes[@id="NCDK.Smiles.SMARTS.Parser.SMARTSParser_Example.cs+1"]/*' />
    /// </para>
    /// <para>See the <see cref="NCDK.Smiles.SMARTS.Parser.ParserTest"/> for examples of the implemented
    /// subset.
    /// </para>
    /// </example>
    /// <remarks>
    /// This parser is based on JJTree and it generates an AST (Abstract Syntax Tree)
    /// <para>To get the AST, the code looks like:
    /// <include file='IncludeExamples.xml' path='Comments/Codes[@id="NCDK.Smiles.SMARTS.Parser.SMARTSParser_Example.cs+2"]/*' />
    /// </para>
    /// </remarks>
    /// <seealso cref="Isomorphisms.Matchers.SMARTS.SMARTSAtom"/>
    // @author      Dazhi Jiao
    // @cdk.created 2007-04-23
    // @cdk.githash
    // @cdk.require ant1.6
    // @cdk.module  smarts
    // @cdk.keyword SMARTS
    // @cdk.keyword substructure search
    public class SMARTSParser/*@bgen(jjtree)*/
    {/*@bgen(jjtree)*/
        protected JJTSMARTSParserState jjtree = new JJTSMARTSParserState();
        private int componentId = 0;

        /// <summary>
        /// This method parses a Smarts String and returns an instance of
        /// <code>QueryAtomContainer</code>
        /// </summary>
        public static QueryAtomContainer Parse(string smarts, IChemObjectBuilder builder)
        {
            QueryAtomContainer container = null;
            StringReader reader = new StringReader(smarts);
            try
            {
                SMARTSParser parser = new SMARTSParser(reader);
                ASTStart start = parser.Start();
                SmartsQueryVisitor visitor
                    = new SmartsQueryVisitor(builder);
                container = (QueryAtomContainer)start.JJTAccept(visitor, null);
            }
            catch (ParseException exception)
            {
                throw new ArgumentException("The string " + smarts + " is not a valid" +
                  " SMARTS string: " + exception.Message, exception);
            }
            return container;
        }

        /// <summary>
        ///                     Start ::= <ReactionExpression> <#_WS>
        ///        ReactionExpression ::= <GroupExpression>? (">" <GroupExpression>? ">" <GroupExpression>?)?
        ///           GroupExpression ::= ["("] <SmartsExpresion> [")"] ( "." ["("] <SmartsExpression> [")"] )*
        ///          SmartsExpression ::= <AtomExpression> (
        /// ( [ <LowAndBond> ] ( <Digit> | <AtomExpression> ) ) |
        /// ( "(" [ <LowAndBond> ] <SmartsExpression> ")" ) )*
        /// AtomExpression ::= ( "[" [ <AtomicMass> ] <LowAndExpression> [:<Digit>+] "]" ) | <ExplicitAtomExpression>
        ///                LowAndBond ::= <OrBond> [ ";" <AndBond> ]
        ///                    OrBond ::= <ExplicitHighAndBond> [ "," <OrBond> ]
        ///       ExplicitHighAndBond ::= <ImplicitHighAndBond> [ "&" <ExplicitHighAndBond> ]
        ///       ImplicitHighAndBond ::= <NotBond> [ <ImplicitHighAndBond> ]
        ///                   NotBond ::= [ "!" ] <SimpleBond>
        ///                SimpleBond ::= "/" | "\\" | "/?" | "\\?" | "=" | "#" | "~" | "@"
        ///    ExplicitAtomExpression ::= [ "B" | "C" | "N" | "O" | "P" | "S" | "F" | "CL" | "BR" | "I"
        ///                               | "c" | "o" | "n" | "*" | "A" | "a" | "p" | "as" | "se" ]
        ///          LowAndExpression ::= <OrExpression> ( ";" <LowAndExpression> )?
        ///              OrExpression ::= <ExplicitHighAndExpression> ( "," <OrExpression> ) ?
        /// ExplicitHighAndExpression ::= <ImplicitHighAndExpression> ( "&" <ExplicitHighAndExpression> )?
        /// ImplicitHighAndExpression ::= <NotExpression> ( <ImplicitHighAndExpression> ) ?
        ///             NotExpression ::= "!" ( <PrimitiveAtomExpression> | <RecursiveSmartsExpression> )
        /// RecursiveSmartsExpression ::= "$" "(" <SmartsExpression> ")"
        ///   PrimitiveAtomExpression ::= <NonHydrogenElement> | "*" | "A" | "a" | "D" (<Digits>)? | "H" (<Digits>)? | "h" (<Digits>)?
        ///                               | "R" (<Digit>+)? | "r" (<Digit>+)? | "v" (<Digit>+)? | "#X" | "G" (<DIGIT>+)
        ///                               | "X" (<Digit>+)? | "x" (<Digit>+)? | "^" (<DIGIT>)
        ///                               | ("+" | "-") (<Digit>+)? | "#" (<Digit>+) | "@" | "@@" | <Digit>+
        ///                     Digit ::= ( "0" - "9")
        ///        NonHydrogenElement ::= [ "HE" | "LI" | "BE" | "NE" | "NA" | "MG" | "AL" | "SI" | "AR" | "CA" | "SC" |
        ///                               "TI" | "CR" | "MN" | "FE" | "CO" | "NI" | "CU" | "ZN" | "GA" | "GE" | "AS" |
        ///                               "SE" | "BR" | "KR" | "RB" | "SR" | "ZR" | "NB" | "MO" | "TC" | "RU" | "RH" |
        ///                               "PD" | "AG" | "CD" | "IN" | "SN" | "SB" | "TE" | "XE" | "CS" | "BA" | "LA" |
        ///                               "HF" | "TA" | "RE" | "OS" | "IR" | "PT" | "AU" | "HG" | "TL" | "PB" | "BI" |
        ///                               "PO" | "AT" | "RN" | "FR" | "RA" | "AC" | "TH" | "PA" |
        ///                               "B" | "C" | "N" | "O" | "F" | "P" | "S" | "K" | "V" | "Y" | "I" | "U" |
        ///                               "c" | "o" | "n" | "p" | "as" | "se" ]
        /// </summary>
        public ASTStart Start()
        {
            /*@bgen(jjtree) Start */
            ASTStart jjtn000 = new ASTStart(JJTSTART);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                ReactionExpression();
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case WS:
                        Jj_consume_token(WS);
                        break;
                    case 0:
                        Jj_consume_token(0);
                        break;
                    default:
                        jj_la1[0] = jj_gen;
                        Jj_consume_token(-1);
                        throw new ParseException();
                }
                jjtree.CloseNodeScope(jjtn000, true);
                jjtc000 = false;
                { if (true) return jjtn000; }
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
            throw new Exception("Missing return statement in function");
        }

         public void ReactionExpression()
        {
            /*@bgen(jjtree) Reaction */
            ASTReaction jjtn000 = new ASTReaction(JJTREACTION);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case c:
                    case n:
                    case o:
                    case s:
                    case p:
                    case as_:
                    case se:
                    case B:
                    case C:
                    case N:
                    case O:
                    case F:
                    case P:
                    case S:
                    case CL:
                    case BR:
                    case I:
                    case WILDCARD:
                    case a:
                    case A:
                    case L_BRACKET:
                    case L_PAREN:
                        GroupExpression();
                        break;
                    default:
                        jj_la1[1] = jj_gen;
                        break;
                }
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case 147:
                        Jj_consume_token(147);
                        if (jjtree.NodeArity() > 0)
                          ((ASTGroup)jjtree.PeekNode()).SetRole(ASTGroup.ROLE_REACTANT);
                        switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                        {
                            case c:
                            case n:
                            case o:
                            case s:
                            case p:
                            case as_:
                            case se:
                            case B:
                            case C:
                            case N:
                            case O:
                            case F:
                            case P:
                            case S:
                            case CL:
                            case BR:
                            case I:
                            case WILDCARD:
                            case a:
                            case A:
                            case L_BRACKET:
                            case L_PAREN:
                                GroupExpression();
                                ((ASTGroup)jjtree.PeekNode()).SetRole(ASTGroup.ROLE_AGENT);
                                break;
                            default:
                                jj_la1[2] = jj_gen;
                                break;
                        }
                        Jj_consume_token(147);
                        switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                        {
                            case c:
                            case n:
                            case o:
                            case s:
                            case p:
                            case as_:
                            case se:
                            case B:
                            case C:
                            case N:
                            case O:
                            case F:
                            case P:
                            case S:
                            case CL:
                            case BR:
                            case I:
                            case WILDCARD:
                            case a:
                            case A:
                            case L_BRACKET:
                            case L_PAREN:
                                GroupExpression();
                                ((ASTGroup)jjtree.PeekNode()).SetRole(ASTGroup.ROLE_PRODUCT);
                                break;
                            default:
                                jj_la1[3] = jj_gen;
                                break;
                        }
                        break;
                    default:
                        jj_la1[4] = jj_gen;
                        break;
                }
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void GroupExpression()
        {
            /*@bgen(jjtree) Group */
            ASTGroup jjtn000 = new ASTGroup(JJTGROUP);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case L_PAREN:
                        Jj_consume_token(L_PAREN);
                        SmartsExpression();
                        ((ASTSmarts)jjtree.PeekNode()).ComponentId = ++componentId;
                        label_1:
                        while (true)
                        {
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case 148:
                                    ;
                                    break;
                                default:
                                    jj_la1[5] = jj_gen;
                                   goto break_label_1;
                            }
                            Jj_consume_token(148);
                            SmartsExpression();
                            // same component grouping
                            ((ASTSmarts)jjtree.PeekNode()).ComponentId = componentId;
                        }
                    break_label_1:
                        Jj_consume_token(R_PAREN);
                        break;
                    case c:
                    case n:
                    case o:
                    case s:
                    case p:
                    case as_:
                    case se:
                    case B:
                    case C:
                    case N:
                    case O:
                    case F:
                    case P:
                    case S:
                    case CL:
                    case BR:
                    case I:
                    case WILDCARD:
                    case a:
                    case A:
                    case L_BRACKET:
                        SmartsExpression();
                        break;
                    default:
                        jj_la1[6] = jj_gen;
                        Jj_consume_token(-1);
                        throw new ParseException();
                }
                label_2:
                while (true)
                {
                    switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                    {
                        case 148:
                            ;
                            break;
                        default:
                            jj_la1[7] = jj_gen;
                            goto break_label_2;
                    }
                    Jj_consume_token(148);
                    switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                    {
                        case L_PAREN:
                            Jj_consume_token(L_PAREN);
                            SmartsExpression();
                            ((ASTSmarts)jjtree.PeekNode()).ComponentId = ++componentId;
                            label_3:
                            while (true)
                            {
                                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                                {
                                    case 148:
                                        ;
                                        break;
                                    default:
                                        jj_la1[8] = jj_gen;
                                        goto break_label_3;
                                }
                                Jj_consume_token(148);
                                SmartsExpression();
                                // same component grouping
                                ((ASTSmarts)jjtree.PeekNode()).ComponentId = componentId;
                            }
                            break_label_3:
                            Jj_consume_token(R_PAREN);
                            break;
                        case c:
                        case n:
                        case o:
                        case s:
                        case p:
                        case as_:
                        case se:
                        case B:
                        case C:
                        case N:
                        case O:
                        case F:
                        case P:
                        case S:
                        case CL:
                        case BR:
                        case I:
                        case WILDCARD:
                        case a:
                        case A:
                        case L_BRACKET:
                            SmartsExpression();
                            break;
                        default:
                            jj_la1[9] = jj_gen;
                            Jj_consume_token(-1);
                            throw new ParseException();
                    }
                }
            break_label_2:
                ;
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void SmartsExpression()
        {
            /*@bgen(jjtree) Smarts */
            ASTSmarts jjtn000 = new ASTSmarts(JJTSMARTS);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); ASTAtom atom;
            int ringIdToken;
            try
            {
                atom = AtomExpression();
                label_4:
                while (true)
                {
                    switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                    {
                        case NOT:
                        case S_BOND:
                        case UP_S_BOND:
                        case DN_S_BOND:
                        case UP_OR_UNSPECIFIED_S_BOND:
                        case DN_OR_UNSPECIFIED_S_BOND:
                        case D_BOND:
                        case T_BOND:
                        case AR_BOND:
                        case ANY_BOND:
                        case R_BOND:
                        case c:
                        case n:
                        case o:
                        case s:
                        case p:
                        case as_:
                        case se:
                        case B:
                        case C:
                        case N:
                        case O:
                        case F:
                        case P:
                        case S:
                        case CL:
                        case BR:
                        case I:
                        case WILDCARD:
                        case a:
                        case A:
                        case DIGIT:
                        case L_BRACKET:
                        case L_PAREN:
                        case DOLLAR:
                        case 149:
                            ;
                            break;
                        default:
                            jj_la1[10] = jj_gen;
                            goto break_label_4;
                    }
                    switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                    {
                        case NOT:
                        case S_BOND:
                        case UP_S_BOND:
                        case DN_S_BOND:
                        case UP_OR_UNSPECIFIED_S_BOND:
                        case DN_OR_UNSPECIFIED_S_BOND:
                        case D_BOND:
                        case T_BOND:
                        case AR_BOND:
                        case ANY_BOND:
                        case R_BOND:
                        case c:
                        case n:
                        case o:
                        case s:
                        case p:
                        case as_:
                        case se:
                        case B:
                        case C:
                        case N:
                        case O:
                        case F:
                        case P:
                        case S:
                        case CL:
                        case BR:
                        case I:
                        case WILDCARD:
                        case a:
                        case A:
                        case DIGIT:
                        case L_BRACKET:
                        case DOLLAR:
                        case 149:
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case NOT:
                                case S_BOND:
                                case UP_S_BOND:
                                case DN_S_BOND:
                                case UP_OR_UNSPECIFIED_S_BOND:
                                case DN_OR_UNSPECIFIED_S_BOND:
                                case D_BOND:
                                case T_BOND:
                                case AR_BOND:
                                case ANY_BOND:
                                case R_BOND:
                                case DOLLAR:
                                    LowAndBond();
                                    break;
                                default:
                                    jj_la1[11] = jj_gen;
                                    break;
                            }
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case DIGIT:
                                case 149:
                                    switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                                    {
                                        case DIGIT:
                                            Jj_consume_token(DIGIT);
                                            ringIdToken = token.image[0] - '0';
                                            break;
                                        case 149:
                                            Jj_consume_token(149);
                                            Jj_consume_token(DIGIT);
                                            ringIdToken = 10 * (token.image[0] - '0');
                                            Jj_consume_token(DIGIT);
                                            ringIdToken += token.image[0] - '0';
                                            break;
                                        default:
                                            jj_la1[12] = jj_gen;
                                            Jj_consume_token(-1);
                                            throw new ParseException();
                                    }
                                    ASTLowAndBond bond = null;
                                    ASTRingIdentifier ringId = new ASTRingIdentifier(JJTRINGIDENTIFIER);
                                    if (jjtree.PeekNode() is ASTLowAndBond)
                                    {
                                        bond = (ASTLowAndBond)jjtree.PopNode(); // pop the bond
                                        ringId.JJTAddChild(bond, 0);
                                    }
                                    ringId.RingId = ringIdToken;
                                    jjtree.PushNode(ringId);
                                    break;
                                case c:
                                case n:
                                case o:
                                case s:
                                case p:
                                case as_:
                                case se:
                                case B:
                                case C:
                                case N:
                                case O:
                                case F:
                                case P:
                                case S:
                                case CL:
                                case BR:
                                case I:
                                case WILDCARD:
                                case a:
                                case A:
                                case L_BRACKET:
                                    atom = AtomExpression();
                                    break;
                                default:
                                    jj_la1[13] = jj_gen;
                                    Jj_consume_token(-1);
                                    throw new ParseException();
                            }
                            break;
                        case L_PAREN:
                            Jj_consume_token(L_PAREN);
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case NOT:
                                case S_BOND:
                                case UP_S_BOND:
                                case DN_S_BOND:
                                case UP_OR_UNSPECIFIED_S_BOND:
                                case DN_OR_UNSPECIFIED_S_BOND:
                                case D_BOND:
                                case T_BOND:
                                case AR_BOND:
                                case ANY_BOND:
                                case R_BOND:
                                case DOLLAR:
                                    LowAndBond();
                                    break;
                                default:
                                    jj_la1[14] = jj_gen;
                                    break;
                            }
                            SmartsExpression();
                            Jj_consume_token(R_PAREN);
                            break;
                        default:
                            jj_la1[15] = jj_gen;
                            Jj_consume_token(-1);
                            throw new ParseException();
                    }
                }
                break_label_4:
                ;
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public ASTAtom AtomExpression()
        {
            /*@bgen(jjtree) Atom */
            ASTAtom jjtn000 = new ASTAtom(JJTATOM);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); Token firstToken;
            Token secondToken;
            Token rightBracket;
            ASTAtomicMass massNode = null;
            StringBuilder mapidx = new StringBuilder();
            try
            {
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case L_BRACKET:
                        Jj_consume_token(L_BRACKET);
                        token_source.SwitchTo(SMARTSParserConstants.ATOM_EXPRESSION);
                        firstToken = GetToken(1);
                        secondToken = GetToken(2);
                        switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                        {
                            case DIGIT:
                                AtomicMass();
                                massNode = (ASTAtomicMass)jjtree.PopNode();
                                break;
                            default:
                                jj_la1[16] = jj_gen;
                                break;
                        }
                        LowAndExpression();
                        if (massNode != null)
                        { // insert AtomicMass node into expression       
                            ASTLowAndExpression topNode = (ASTLowAndExpression)jjtree.PopNode();
                            topNode.InsertLeafChild(massNode);
                            jjtree.PushNode(topNode);
                        }
                        switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                        {
                            case AR_BOND:
                                Jj_consume_token(AR_BOND);
                                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                                {
                                    case Q_MARK:
                                        Jj_consume_token(Q_MARK);
                                        break;
                                    default:
                                        jj_la1[17] = jj_gen;
                                        break;
                                }
                                label_5:
                                while (true)
                                {
                                    Jj_consume_token(DIGIT);
                                    mapidx.Append(token.image);
                                    switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                                    {
                                        case DIGIT:
                                            ;
                                            break;
                                        default:
                                            jj_la1[18] = jj_gen;
                                          goto break_label_5;
                                    }
                                }
                                break_label_5:
                                   ((ASTLowAndExpression)jjtree.PeekNode()).SetMapIdx(int.Parse(mapidx.ToString()));
                                break;
                            default:
                                jj_la1[19] = jj_gen;
                                break;
                        }
                        Jj_consume_token(R_BRACKET);
                        token_source.SwitchTo(SMARTSParserConstants.Default); rightBracket = token;
                        Token HToken = null;
                        // If the LowAndExpression is "[H]", change it to an ExplicitAtom
                        if (firstToken.image.Equals("H"))
                        {
                            HToken = firstToken;
                        }
                        else if (massNode != null && massNode.Mass <= 3 && secondToken != null && secondToken.image.Equals("H"))
                        {
                            HToken = secondToken;
                        }
                        if (HToken != null)
                        {
                            if ((rightBracket.beginColumn - HToken.endColumn) == 1)
                            {
                                jjtree.PopNode();
                                ASTExplicitAtom explicitAtom = new ASTExplicitAtom(JJTEXPLICITATOM);
                                if (massNode != null)
                                {
                                    if (massNode.Mass == 2) explicitAtom.Symbol = "D";
                                    else if (massNode.Mass == 3) explicitAtom.Symbol = "T";
                                    else if (massNode.Mass == 1) explicitAtom.Symbol = "H";
                                }
                                else
                                {
                                    explicitAtom.Symbol = "H";
                                }
                                jjtree.PushNode(explicitAtom);
                            }
                        }
                        break;
                    case c:
                    case n:
                    case o:
                    case s:
                    case p:
                    case as_:
                    case se:
                    case B:
                    case C:
                    case N:
                    case O:
                    case F:
                    case P:
                    case S:
                    case CL:
                    case BR:
                    case I:
                    case WILDCARD:
                    case a:
                    case A:
                        ExplicitAtomExpression();
                        break;
                    default:
                        jj_la1[20] = jj_gen;
                        Jj_consume_token(-1);
                        throw new ParseException();
                }
                jjtree.CloseNodeScope(jjtn000, true);
                jjtc000 = false;
                { if (true) return jjtn000; }
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
            throw new Exception("Missing return statement in function");
        }

         public void LowAndBond()
        {
            /*@bgen(jjtree) LowAndBond */
            ASTLowAndBond jjtn000 = new ASTLowAndBond(JJTLOWANDBOND);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                OrBond();
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case L_AND:
                        Jj_consume_token(L_AND);
                        LowAndBond();
                        break;
                    default:
                        jj_la1[21] = jj_gen;
                        break;
                }
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void OrBond()
        {
            /*@bgen(jjtree) OrBond */
            ASTOrBond jjtn000 = new ASTOrBond(JJTORBOND);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                ExplicitHighAndBond();
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case OR:
                        Jj_consume_token(OR);
                        OrBond();
                        break;
                    default:
                        jj_la1[22] = jj_gen;
                        break;
                }
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void ExplicitHighAndBond()
        {
            /*@bgen(jjtree) ExplicitHighAndBond */
            ASTExplicitHighAndBond jjtn000 = new ASTExplicitHighAndBond(JJTEXPLICITHIGHANDBOND);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                ImplicitHighAndBond();
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case H_AND:
                        Jj_consume_token(H_AND);
                        ExplicitHighAndBond();
                        break;
                    default:
                        jj_la1[23] = jj_gen;
                        break;
                }
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void ImplicitHighAndBond()
        {
            /*@bgen(jjtree) ImplicitHighAndBond */
            ASTImplicitHighAndBond jjtn000 = new ASTImplicitHighAndBond(JJTIMPLICITHIGHANDBOND);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                NotBond();
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case NOT:
                    case S_BOND:
                    case UP_S_BOND:
                    case DN_S_BOND:
                    case UP_OR_UNSPECIFIED_S_BOND:
                    case DN_OR_UNSPECIFIED_S_BOND:
                    case D_BOND:
                    case T_BOND:
                    case AR_BOND:
                    case ANY_BOND:
                    case R_BOND:
                    case DOLLAR:
                        ImplicitHighAndBond();
                        break;
                    default:
                        jj_la1[24] = jj_gen;
                        break;
                }
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void NotBond()
        {
            /*@bgen(jjtree) NotBond */
            ASTNotBond jjtn000 = new ASTNotBond(JJTNOTBOND);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case NOT:
                        Jj_consume_token(NOT);
                        jjtn000.Type = SMARTSParserConstants.NOT;
                        break;
                    default:
                        jj_la1[25] = jj_gen;
                        break;
                }
                SimpleBond();
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void SimpleBond()
        {
            /*@bgen(jjtree) SimpleBond */
            ASTSimpleBond jjtn000 = new ASTSimpleBond(JJTSIMPLEBOND);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                if (Jj_2_1(2))
                {
                    Jj_consume_token(S_BOND);
                }
                else
                {
                    switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                    {
                        case UP_S_BOND:
                            Jj_consume_token(UP_S_BOND);
                            break;
                        case DN_S_BOND:
                            Jj_consume_token(DN_S_BOND);
                            break;
                        case UP_OR_UNSPECIFIED_S_BOND:
                            Jj_consume_token(UP_OR_UNSPECIFIED_S_BOND);
                            break;
                        case DN_OR_UNSPECIFIED_S_BOND:
                            Jj_consume_token(DN_OR_UNSPECIFIED_S_BOND);
                            break;
                        case D_BOND:
                            Jj_consume_token(D_BOND);
                            break;
                        case T_BOND:
                            Jj_consume_token(T_BOND);
                            break;
                        case DOLLAR:
                            Jj_consume_token(DOLLAR);
                            break;
                        case AR_BOND:
                            Jj_consume_token(AR_BOND);
                            break;
                        case ANY_BOND:
                            Jj_consume_token(ANY_BOND);
                            break;
                        case R_BOND:
                            Jj_consume_token(R_BOND);
                            break;
                        default:
                            jj_la1[26] = jj_gen;
                            Jj_consume_token(-1);
                            throw new ParseException();
                    }
                }
                jjtree.CloseNodeScope(jjtn000, true);
                jjtc000 = false;
                jjtn000.BondType = token.kind;
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void ExplicitAtomExpression()
        {
            /*@bgen(jjtree) ExplicitAtom */
            ASTExplicitAtom jjtn000 = new ASTExplicitAtom(JJTEXPLICITATOM);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case B:
                        Jj_consume_token(B);
                        break;
                    case C:
                        Jj_consume_token(C);
                        break;
                    case N:
                        Jj_consume_token(N);
                        break;
                    case O:
                        Jj_consume_token(O);
                        break;
                    case P:
                        Jj_consume_token(P);
                        break;
                    case S:
                        Jj_consume_token(S);
                        break;
                    case F:
                        Jj_consume_token(F);
                        break;
                    case CL:
                        Jj_consume_token(CL);
                        break;
                    case BR:
                        Jj_consume_token(BR);
                        break;
                    case I:
                        Jj_consume_token(I);
                        break;
                    case WILDCARD:
                        Jj_consume_token(WILDCARD);
                        break;
                    case A:
                        Jj_consume_token(A);
                        break;
                    case a:
                        Jj_consume_token(a);
                        break;
                    case c:
                        Jj_consume_token(c);
                        break;
                    case n:
                        Jj_consume_token(n);
                        break;
                    case o:
                        Jj_consume_token(o);
                        break;
                    case s:
                        Jj_consume_token(s);
                        break;
                    case p:
                        Jj_consume_token(p);
                        break;
                    case se:
                        Jj_consume_token(se);
                        break;
                    case as_:
                        Jj_consume_token(as_);
                        break;
                    default:
                        jj_la1[27] = jj_gen;
                        Jj_consume_token(-1);
                        throw new ParseException();
                }
                jjtree.CloseNodeScope(jjtn000, true);
                jjtc000 = false;
                jjtn000.Symbol = token.image;
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

        // TODO: This requires a fully implemented SMARTSAtom API (or something else) that 
        // could encapsulate logical criterias
         public void LowAndExpression()
        {
            /*@bgen(jjtree) LowAndExpression */
            ASTLowAndExpression jjtn000 = new ASTLowAndExpression(JJTLOWANDEXPRESSION);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                OrExpression();
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case L_AND:
                        Jj_consume_token(L_AND);
                        LowAndExpression();
                        break;
                    default:
                        jj_la1[28] = jj_gen;
                        break;
                }
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void OrExpression()
        {
            /*@bgen(jjtree) OrExpression */
            ASTOrExpression jjtn000 = new ASTOrExpression(JJTOREXPRESSION);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                ExplicitHighAndExpression();
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case OR:
                        Jj_consume_token(OR);
                        OrExpression();
                        break;
                    default:
                        jj_la1[29] = jj_gen;
                        break;
                }
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void ExplicitHighAndExpression()
        {
            /*@bgen(jjtree) ExplicitHighAndExpression */
            ASTExplicitHighAndExpression jjtn000 = new ASTExplicitHighAndExpression(JJTEXPLICITHIGHANDEXPRESSION);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                ImplicitHighAndExpression();
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case H_AND:
                        Jj_consume_token(H_AND);
                        ExplicitHighAndExpression();
                        break;
                    default:
                        jj_la1[30] = jj_gen;
                        break;
                }
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void ImplicitHighAndExpression()
        {
            /*@bgen(jjtree) ImplicitHighAndExpression */
            ASTImplicitHighAndExpression jjtn000 = new ASTImplicitHighAndExpression(JJTIMPLICITHIGHANDEXPRESSION);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                NotExpression();
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case NOT:
                    case S_BOND:
                    case T_BOND:
                    case R_BOND:
                    case c:
                    case n:
                    case o:
                    case s:
                    case p:
                    case as_:
                    case se:
                    case B:
                    case C:
                    case N:
                    case O:
                    case F:
                    case P:
                    case S:
                    case CL:
                    case BR:
                    case I:
                    case WILDCARD:
                    case a:
                    case A:
                    case CARET:
                    case DOLLAR:
                    case PLUS:
                    case h:
                    case D:
                    case R:
                    case r:
                    case v:
                    case X:
                    case x:
                    case G:
                    case HX:
                    case H:
                    case HE:
                    case LI:
                    case BE:
                    case NE:
                    case NA:
                    case MG:
                    case AL:
                    case SI:
                    case AR:
                    case K:
                    case CA:
                    case TI:
                    case V:
                    case CR:
                    case MN:
                    case FE:
                    case CO:
                    case NI:
                    case CU:
                    case ZN:
                    case GA:
                    case GE:
                    case AS:
                    case SE:
                    case KR:
                    case RB:
                    case SR:
                    case Y:
                    case ZR:
                    case NB:
                    case MO:
                    case TC:
                    case RU:
                    case RH:
                    case PD:
                    case AG:
                    case CD:
                    case IN:
                    case SN:
                    case SB:
                    case TE:
                    case XE:
                    case CS:
                    case BA:
                    case LA:
                    case HF:
                    case TA:
                    case W:
                    case RE:
                    case OS:
                    case IR:
                    case PT:
                    case AU:
                    case HG:
                    case TL:
                    case PB:
                    case BI:
                    case PO:
                    case AT:
                    case RN:
                    case FR:
                    case RA:
                    case AC:
                    case TH:
                    case PA:
                    case U:
                    case PU:
                    case AM:
                    case CM:
                    case BK:
                    case CF:
                    case ES:
                    case FM:
                    case MD:
                    case NO:
                    case LR:
                    case NP:
                    case CE:
                    case ND:
                    case PM:
                    case SM:
                    case EU:
                    case GD:
                    case TB:
                    case DY:
                    case HO:
                    case ER:
                    case TM:
                    case YB:
                    case LU:
                    case PR:
                    case SC:
                    case 150:
                    case 151:
                    case 152:
                    case 153:
                    case 154:
                    case 155:
                    case 156:
                    case 157:
                    case 158:
                    case 159:
                    case 160:
                    case 161:
                    case 162:
                    case 163:
                        ImplicitHighAndExpression();
                        break;
                    default:
                        jj_la1[31] = jj_gen;
                        break;
                }
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void NotExpression()
        {
            /*@bgen(jjtree) NotExpression */
            ASTNotExpression jjtn000 = new ASTNotExpression(JJTNOTEXPRESSION);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); jjtn000.Type = SMARTSParserConstants.Default;
            try
            {
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case NOT:
                        Jj_consume_token(NOT);
                        jjtn000.Type = SMARTSParserConstants.NOT;
                        break;
                    default:
                        jj_la1[32] = jj_gen;
                        break;
                }
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case S_BOND:
                    case T_BOND:
                    case R_BOND:
                    case c:
                    case n:
                    case o:
                    case s:
                    case p:
                    case as_:
                    case se:
                    case B:
                    case C:
                    case N:
                    case O:
                    case F:
                    case P:
                    case S:
                    case CL:
                    case BR:
                    case I:
                    case WILDCARD:
                    case a:
                    case A:
                    case CARET:
                    case PLUS:
                    case h:
                    case D:
                    case R:
                    case r:
                    case v:
                    case X:
                    case x:
                    case G:
                    case HX:
                    case H:
                    case HE:
                    case LI:
                    case BE:
                    case NE:
                    case NA:
                    case MG:
                    case AL:
                    case SI:
                    case AR:
                    case K:
                    case CA:
                    case TI:
                    case V:
                    case CR:
                    case MN:
                    case FE:
                    case CO:
                    case NI:
                    case CU:
                    case ZN:
                    case GA:
                    case GE:
                    case AS:
                    case SE:
                    case KR:
                    case RB:
                    case SR:
                    case Y:
                    case ZR:
                    case NB:
                    case MO:
                    case TC:
                    case RU:
                    case RH:
                    case PD:
                    case AG:
                    case CD:
                    case IN:
                    case SN:
                    case SB:
                    case TE:
                    case XE:
                    case CS:
                    case BA:
                    case LA:
                    case HF:
                    case TA:
                    case W:
                    case RE:
                    case OS:
                    case IR:
                    case PT:
                    case AU:
                    case HG:
                    case TL:
                    case PB:
                    case BI:
                    case PO:
                    case AT:
                    case RN:
                    case FR:
                    case RA:
                    case AC:
                    case TH:
                    case PA:
                    case U:
                    case PU:
                    case AM:
                    case CM:
                    case BK:
                    case CF:
                    case ES:
                    case FM:
                    case MD:
                    case NO:
                    case LR:
                    case NP:
                    case CE:
                    case ND:
                    case PM:
                    case SM:
                    case EU:
                    case GD:
                    case TB:
                    case DY:
                    case HO:
                    case ER:
                    case TM:
                    case YB:
                    case LU:
                    case PR:
                    case SC:
                    case 150:
                    case 151:
                    case 152:
                    case 153:
                    case 154:
                    case 155:
                    case 156:
                    case 157:
                    case 158:
                    case 159:
                    case 160:
                    case 161:
                    case 162:
                    case 163:
                        PrimitiveAtomExpression();
                        break;
                    case DOLLAR:
                        RecursiveSmartsExpression();
                        break;
                    default:
                        jj_la1[33] = jj_gen;
                        Jj_consume_token(-1);
                        throw new ParseException();
                }
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void RecursiveSmartsExpression()
        {
            /*@bgen(jjtree) RecursiveSmartsExpression */
            ASTRecursiveSmartsExpression jjtn000 = new ASTRecursiveSmartsExpression(JJTRECURSIVESMARTSEXPRESSION);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                Jj_consume_token(DOLLAR);
                Jj_consume_token(L_PAREN);
                token_source.SwitchTo(SMARTSParserConstants.Default);
                GroupExpression();
                Jj_consume_token(R_PAREN);
                jjtree.CloseNodeScope(jjtn000, true);
                jjtc000 = false;
                token_source.SwitchTo(SMARTSParserConstants.ATOM_EXPRESSION);
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void PrimitiveAtomExpression()
        {
            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
            {
                case c:
                case n:
                case o:
                case s:
                case p:
                case as_:
                case se:
                case B:
                case C:
                case N:
                case O:
                case F:
                case P:
                case S:
                case CL:
                case BR:
                case I:
                case HE:
                case LI:
                case BE:
                case NE:
                case NA:
                case MG:
                case AL:
                case SI:
                case AR:
                case K:
                case CA:
                case TI:
                case V:
                case CR:
                case MN:
                case FE:
                case CO:
                case NI:
                case CU:
                case ZN:
                case GA:
                case GE:
                case AS:
                case SE:
                case KR:
                case RB:
                case SR:
                case Y:
                case ZR:
                case NB:
                case MO:
                case TC:
                case RU:
                case RH:
                case PD:
                case AG:
                case CD:
                case IN:
                case SN:
                case SB:
                case TE:
                case XE:
                case CS:
                case BA:
                case LA:
                case HF:
                case TA:
                case W:
                case RE:
                case OS:
                case IR:
                case PT:
                case AU:
                case HG:
                case TL:
                case PB:
                case BI:
                case PO:
                case AT:
                case RN:
                case FR:
                case RA:
                case AC:
                case TH:
                case PA:
                case U:
                case PU:
                case AM:
                case CM:
                case BK:
                case CF:
                case ES:
                case FM:
                case MD:
                case NO:
                case LR:
                case NP:
                case CE:
                case ND:
                case PM:
                case SM:
                case EU:
                case GD:
                case TB:
                case DY:
                case HO:
                case ER:
                case TM:
                case YB:
                case LU:
                case PR:
                case SC:
                    NoHydrogenElement();
                    break;
                case WILDCARD:
                    AnyAtom();
                    break;
                case a:
                    Aromatic();
                    break;
                case A:
                    Aliphatic();
                    break;
                case D:
                    ExplicitConnectivity();
                    break;
                case H:
                    TotalHCount();
                    break;
                case h:
                    ImplicitHCount();
                    break;
                case R:
                    RingMembership();
                    break;
                case r:
                    SmallestRingSize();
                    break;
                case v:
                    Valence();
                    break;
                case X:
                    TotalConnectivity();
                    break;
                case x:
                    RingConnectivity();
                    break;
                case S_BOND:
                case PLUS:
                case 150:
                case 151:
                case 152:
                case 153:
                case 154:
                case 155:
                case 156:
                case 157:
                case 158:
                case 159:
                case 160:
                case 161:
                case 162:
                case 163:
                    Charge();
                    break;
                case T_BOND:
                    AtomicNumber();
                    break;
                case R_BOND:
                    Chirality();
                    break;
                case G:
                    PeriodicGroupNumber();
                    break;
                case HX:
                    NonCHHeavyAtom();
                    break;
                case CARET:
                    HybridizationNumber();
                    break;
                default:
                    jj_la1[34] = jj_gen;
                    Jj_consume_token(-1);
                    throw new ParseException();
            }
        }

         public void TotalHCount()
        {
            /*@bgen(jjtree) TotalHCount */
            ASTTotalHCount jjtn000 = new ASTTotalHCount(JJTTOTALHCOUNT);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); StringBuilder digits = new StringBuilder();
            try
            {
                Jj_consume_token(H);
                jjtn000.Count = 1;
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case DIGIT:
                        label_6:
                        while (true)
                        {
                            Jj_consume_token(DIGIT);
                            digits.Append(token.image);
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case DIGIT:
                                    ;
                                    break;
                                default:
                                    jj_la1[35] = jj_gen;
                                    goto break_label_6;
                            }
                        }
                        break_label_6:
                        jjtn000.Count = int.Parse(digits.ToString());
                        break;
                    default:
                        jj_la1[36] = jj_gen;
                        break;
                }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void ImplicitHCount()
        {
            /*@bgen(jjtree) ImplicitHCount */
            ASTImplicitHCount jjtn000 = new ASTImplicitHCount(JJTIMPLICITHCOUNT);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); StringBuilder digits = new StringBuilder();
            try
            {
                Jj_consume_token(h);
                jjtn000.Count = 1;
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case DIGIT:
                        label_7:
                        while (true)
                        {
                            Jj_consume_token(DIGIT);
                            digits.Append(token.image);
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case DIGIT:
                                    ;
                                    break;
                                default:
                                    jj_la1[37] = jj_gen;
                                    goto break_label_7;
                            }
                        }
                        break_label_7:
                        jjtn000.Count = int.Parse(digits.ToString());
                        break;
                    default:
                        jj_la1[38] = jj_gen;
                        break;
                }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void ExplicitConnectivity()
        {
            /*@bgen(jjtree) ExplicitConnectivity */
            ASTExplicitConnectivity jjtn000 = new ASTExplicitConnectivity(JJTEXPLICITCONNECTIVITY);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); StringBuilder digits = new StringBuilder();
            try
            {
                Jj_consume_token(D);
                jjtn000.NumOfConnection = 1;
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case DIGIT:
                        label_8:
                        while (true)
                        {
                            Jj_consume_token(DIGIT);
                            digits.Append(token.image);
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case DIGIT:
                                    ;
                                    break;
                                default:
                                    jj_la1[39] = jj_gen;
                                    goto break_label_8;
                            }
                        }
                        break_label_8:
                        jjtn000.NumOfConnection = int.Parse(digits.ToString());
                        break;
                    default:
                        jj_la1[40] = jj_gen;
                        break;
                }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void AtomicNumber()
        {
            /*@bgen(jjtree) AtomicNumber */
            ASTAtomicNumber jjtn000 = new ASTAtomicNumber(JJTATOMICNUMBER);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); StringBuilder digits = new StringBuilder();
            try
            {
                Jj_consume_token(T_BOND);
                label_9:
                while (true)
                {
                    Jj_consume_token(DIGIT);
                    digits.Append(token.image);
                    switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                    {
                        case DIGIT:
                            ;
                            break;
                        default:
                            jj_la1[41] = jj_gen;
                            goto break_label_9;
                    }
                }
                break_label_9:
                jjtree.CloseNodeScope(jjtn000, true);
                jjtc000 = false;
                jjtn000.Number = int.Parse(digits.ToString());
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void HybridizationNumber()
        {
            /*@bgen(jjtree) HybrdizationNumber */
            ASTHybrdizationNumber jjtn000 = new ASTHybrdizationNumber(JJTHYBRDIZATIONNUMBER);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                Jj_consume_token(CARET);
                Jj_consume_token(DIGIT);
                jjtree.CloseNodeScope(jjtn000, true);
                jjtc000 = false;
                int tmp = int.Parse(token.image);
                if (tmp < 1 || tmp > 8) { if (true) throw new ParseException("Hybridization number must be between 1 & 8"); }
                jjtn000.HybridizationNumber = tmp;
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void Charge()
        {
            /*@bgen(jjtree) Charge */
            ASTCharge jjtn000 = new ASTCharge(JJTCHARGE);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); StringBuilder digits = new StringBuilder();
            try
            {
                if (Jj_2_2(2))
                {
                    Jj_consume_token(PLUS);
                    jjtn000.IsPositive = true; jjtn000.Charge = 1;
                    switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                    {
                        case DIGIT:
                            label_10:
                            while (true)
                            {
                                Jj_consume_token(DIGIT);
                                digits.Append(token.image);
                                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                                {
                                    case DIGIT:
                                        ;
                                        break;
                                    default:
                                        jj_la1[42] = jj_gen;
                                        goto break_label_10;
                                }
                            }
                            break_label_10:
                            jjtn000.Charge = int.Parse(digits.ToString());
                            break;
                        default:
                            jj_la1[43] = jj_gen;
                            break;
                    }
                }
                else
                {
                    switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                    {
                        case S_BOND:
                            Jj_consume_token(S_BOND);
                            jjtn000.IsPositive = false; jjtn000.Charge = 1;
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case DIGIT:
                                    label_11:
                                    while (true)
                                    {
                                        Jj_consume_token(DIGIT);
                                        digits.Append(token.image);
                                        switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                                        {
                                            case DIGIT:
                                                ;
                                                break;
                                            default:
                                                jj_la1[44] = jj_gen;
                                               goto break_label_11;
                                        }
                                    }
                                    break_label_11:
                                    jjtn000.Charge = int.Parse(digits.ToString());
                                    break;
                                default:
                                    jj_la1[45] = jj_gen;
                                    break;
                            }
                            break;
                        case 150:
                            Jj_consume_token(150);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = false; jjtn000.Charge = 2;
                            break;
                        case 151:
                            Jj_consume_token(151);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = false; jjtn000.Charge = 3;
                            break;
                        case 152:
                            Jj_consume_token(152);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = false; jjtn000.Charge = 4;
                            break;
                        case 153:
                            Jj_consume_token(153);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = false; jjtn000.Charge = 5;
                            break;
                        case 154:
                            Jj_consume_token(154);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = false; jjtn000.Charge = 6;
                            break;
                        case 155:
                            Jj_consume_token(155);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = false; jjtn000.Charge = 7;
                            break;
                        case 156:
                            Jj_consume_token(156);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = false; jjtn000.Charge = 8;
                            break;
                        case 157:
                            Jj_consume_token(157);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = true; jjtn000.Charge = 2;
                            break;
                        case 158:
                            Jj_consume_token(158);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = true; jjtn000.Charge = 3;
                            break;
                        case 159:
                            Jj_consume_token(159);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = true; jjtn000.Charge = 4;
                            break;
                        case 160:
                            Jj_consume_token(160);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = true; jjtn000.Charge = 5;
                            break;
                        case 161:
                            Jj_consume_token(161);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = true; jjtn000.Charge = 6;
                            break;
                        case 162:
                            Jj_consume_token(162);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = true; jjtn000.Charge = 7;
                            break;
                        case 163:
                            Jj_consume_token(163);
                            jjtree.CloseNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtn000.IsPositive = true; jjtn000.Charge = 8;
                            break;
                        default:
                            jj_la1[46] = jj_gen;
                            Jj_consume_token(-1);
                            throw new ParseException();
                    }
                }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void RingConnectivity()
        {
            /*@bgen(jjtree) RingConnectivity */
            ASTRingConnectivity jjtn000 = new ASTRingConnectivity(JJTRINGCONNECTIVITY);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                Jj_consume_token(x);
                jjtn000.NumOfConnection = 1;
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case DIGIT:
                        label_12:
                        while (true)
                        {
                            Jj_consume_token(DIGIT);
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case DIGIT:
                                    ;
                                    break;
                                default:
                                    jj_la1[47] = jj_gen;
                                    goto break_label_12;
                            }
                        }
                        break_label_12:
                        jjtn000.NumOfConnection = int.Parse(token.image);
                        break;
                    default:
                        jj_la1[48] = jj_gen;
                        break;
                }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void PeriodicGroupNumber()
        {
            /*@bgen(jjtree) PeriodicGroupNumber */
            ASTPeriodicGroupNumber jjtn000 = new ASTPeriodicGroupNumber(JJTPERIODICGROUPNUMBER);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); StringBuilder digits = new StringBuilder();
            try
            {
                Jj_consume_token(G);

                label_13:
                while (true)
                {
                    Jj_consume_token(DIGIT);
                    digits.Append(token.image);
                    switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                    {
                        case DIGIT:
                            ;
                            break;
                        default:
                            jj_la1[49] = jj_gen;
                            goto break_label_13;
                    }
                }
                break_label_13:
                jjtree.CloseNodeScope(jjtn000, true);
                jjtc000 = false;
                int tmpInt = int.Parse(digits.ToString());
                if (tmpInt < 1 || tmpInt > 18) { if (true) throw new ParseException("Invalid group number"); }
                jjtn000.GroupNumber= int.Parse(digits.ToString());
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void TotalConnectivity()
        {
            /*@bgen(jjtree) TotalConnectivity */
            ASTTotalConnectivity jjtn000 = new ASTTotalConnectivity(JJTTOTALCONNECTIVITY);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); StringBuilder digits = new StringBuilder();
            try
            {
                Jj_consume_token(X);
                jjtn000.NumOfConnection = 1;
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case DIGIT:
                        label_14:
                        while (true)
                        {
                            Jj_consume_token(DIGIT);
                            digits.Append(token.image);
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case DIGIT:
                                    ;
                                    break;
                                default:
                                    jj_la1[50] = jj_gen;
                                    goto break_label_14;
                            }
                        }
                        break_label_14:
                        jjtn000.NumOfConnection = int.Parse(digits.ToString());
                        break;
                    default:
                        jj_la1[51] = jj_gen;
                        break;
                }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void Valence()
        {
            /*@bgen(jjtree) Valence */
            ASTValence jjtn000 = new ASTValence(JJTVALENCE);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); StringBuilder digits = new StringBuilder();
            try
            {
                Jj_consume_token(v);
                jjtn000.Order = 1;
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case DIGIT:
                        label_15:
                        while (true)
                        {
                            Jj_consume_token(DIGIT);
                            digits.Append(token.image);
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case DIGIT:
                                    ;
                                    break;
                                default:
                                    jj_la1[52] = jj_gen;
                                    goto break_label_15;
                            }
                        }
                        break_label_15:
                        jjtn000.Order = int.Parse(digits.ToString());
                        break;
                    default:
                        jj_la1[53] = jj_gen;
                        break;
                }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void RingMembership()
        {
            /*@bgen(jjtree) RingMembership */
            ASTRingMembership jjtn000 = new ASTRingMembership(JJTRINGMEMBERSHIP);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); StringBuilder digits = new StringBuilder();
            try
            {
                Jj_consume_token(R);
                jjtn000.NumOfMembership = -1;
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case DIGIT:
                        label_16:
                        while (true)
                        {
                            Jj_consume_token(DIGIT);
                            digits.Append(token.image);
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case DIGIT:
                                    ;
                                    break;
                                default:
                                    jj_la1[54] = jj_gen;
                                    goto break_label_16;
                            }
                        }
                        break_label_16:
                        jjtn000.NumOfMembership = int.Parse(digits.ToString());
                        break;
                    default:
                        jj_la1[55] = jj_gen;
                        break;
                }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void SmallestRingSize()
        {
            /*@bgen(jjtree) SmallestRingSize */
            ASTSmallestRingSize jjtn000 = new ASTSmallestRingSize(JJTSMALLESTRINGSIZE);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); StringBuilder digits = new StringBuilder();
            try
            {
                Jj_consume_token(r);
                jjtn000.Size = -1;
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case DIGIT:
                        label_17:
                        while (true)
                        {
                            Jj_consume_token(DIGIT);
                            digits.Append(token.image);
                            switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                            {
                                case DIGIT:
                                    ;
                                    break;
                                default:
                                    jj_la1[56] = jj_gen;
                                    goto break_label_17;
                            }
                        }
                        break_label_17:
                        jjtn000.Size = int.Parse(digits.ToString());
                        break;
                    default:
                        jj_la1[57] = jj_gen;
                        break;
                }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void Aliphatic()
        {
            /*@bgen(jjtree) Aliphatic */
            ASTAliphatic jjtn000 = new ASTAliphatic(JJTALIPHATIC);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                Jj_consume_token(A);
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void NonCHHeavyAtom()
        {
            /*@bgen(jjtree) NonCHHeavyAtom */
            ASTNonCHHeavyAtom jjtn000 = new ASTNonCHHeavyAtom(JJTNONCHHEAVYATOM);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                Jj_consume_token(HX);
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void Aromatic()
        {
            /*@bgen(jjtree) Aromatic */
            ASTAromatic jjtn000 = new ASTAromatic(JJTAROMATIC);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                Jj_consume_token(a);
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void AnyAtom()
        {
            /*@bgen(jjtree) AnyAtom */
            ASTAnyAtom jjtn000 = new ASTAnyAtom(JJTANYATOM);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                Jj_consume_token(WILDCARD);
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void AtomicMass()
        {
            /*@bgen(jjtree) AtomicMass */
            ASTAtomicMass jjtn000 = new ASTAtomicMass(JJTATOMICMASS);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); StringBuilder digits = new StringBuilder();
            try
            {
                label_18:
                while (true)
                {
                    Jj_consume_token(DIGIT);
                    digits.Append(token.image);
                    switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                    {
                        case DIGIT:
                            ;
                            break;
                        default:
                            jj_la1[58] = jj_gen;
                            goto break_label_18;
                    }
                }
                break_label_18:
                jjtree.CloseNodeScope(jjtn000, true);
                jjtc000 = false;
                jjtn000.Mass = int.Parse(digits.ToString());
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void RingIdentifier()
        {
            /*@bgen(jjtree) RingIdentifier */
            ASTRingIdentifier jjtn000 = new ASTRingIdentifier(JJTRINGIDENTIFIER);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                LowAndBond();
                Jj_consume_token(DIGIT);
            }
            catch (Exception jjte000)
            {
                if (jjtc000)
                {
                    jjtree.ClearNodeScope(jjtn000);
                    jjtc000 = false;
                }
                else
                {
                    jjtree.PopNode();
                }
                if (jjte000 is ParseException)
                {
                    { if (true) throw (ParseException)jjte000; }
                }
                { if (true) throw (Exception)jjte000; }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void Chirality()
        {
            /*@bgen(jjtree) Chirality */
            ASTChirality jjtn000 = new ASTChirality(JJTCHIRALITY);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000); StringBuilder digits = new StringBuilder();
            try
            {
                Jj_consume_token(R_BOND);
                jjtn000.IsClockwise = false;
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case R_BOND:
                        Jj_consume_token(R_BOND);
                        jjtn000.IsClockwise = true;
                        break;
                    default:
                        jj_la1[59] = jj_gen;
                        break;
                }
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case Q_MARK:
                        Jj_consume_token(Q_MARK);
                        jjtn000.IsUnspecified= true;
                        break;
                    default:
                        jj_la1[60] = jj_gen;
                        break;
                }
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

         public void NoHydrogenElement()
        {
            /*@bgen(jjtree) Element */
            ASTElement jjtn000 = new ASTElement(JJTELEMENT);
            bool jjtc000 = true;
            jjtree.OpenNodeScope(jjtn000);
            try
            {
                switch ((jj_ntk == -1) ? Jj_ntk() : jj_ntk)
                {
                    case HE:
                        Jj_consume_token(HE);
                        break;
                    case LI:
                        Jj_consume_token(LI);
                        break;
                    case BE:
                        Jj_consume_token(BE);
                        break;
                    case NE:
                        Jj_consume_token(NE);
                        break;
                    case NA:
                        Jj_consume_token(NA);
                        break;
                    case MG:
                        Jj_consume_token(MG);
                        break;
                    case AL:
                        Jj_consume_token(AL);
                        break;
                    case SI:
                        Jj_consume_token(SI);
                        break;
                    case AR:
                        Jj_consume_token(AR);
                        break;
                    case CA:
                        Jj_consume_token(CA);
                        break;
                    case SC:
                        Jj_consume_token(SC);
                        break;
                    case TI:
                        Jj_consume_token(TI);
                        break;
                    case CR:
                        Jj_consume_token(CR);
                        break;
                    case MN:
                        Jj_consume_token(MN);
                        break;
                    case FE:
                        Jj_consume_token(FE);
                        break;
                    case CO:
                        Jj_consume_token(CO);
                        break;
                    case NI:
                        Jj_consume_token(NI);
                        break;
                    case CU:
                        Jj_consume_token(CU);
                        break;
                    case ZN:
                        Jj_consume_token(ZN);
                        break;
                    case GA:
                        Jj_consume_token(GA);
                        break;
                    case GE:
                        Jj_consume_token(GE);
                        break;
                    case AS:
                        Jj_consume_token(AS);
                        break;
                    case SE:
                        Jj_consume_token(SE);
                        break;
                    case BR:
                        Jj_consume_token(BR);
                        break;
                    case KR:
                        Jj_consume_token(KR);
                        break;
                    case RB:
                        Jj_consume_token(RB);
                        break;
                    case SR:
                        Jj_consume_token(SR);
                        break;
                    case ZR:
                        Jj_consume_token(ZR);
                        break;
                    case NB:
                        Jj_consume_token(NB);
                        break;
                    case MO:
                        Jj_consume_token(MO);
                        break;
                    case TC:
                        Jj_consume_token(TC);
                        break;
                    case RU:
                        Jj_consume_token(RU);
                        break;
                    case RH:
                        Jj_consume_token(RH);
                        break;
                    case PD:
                        Jj_consume_token(PD);
                        break;
                    case AG:
                        Jj_consume_token(AG);
                        break;
                    case CD:
                        Jj_consume_token(CD);
                        break;
                    case IN:
                        Jj_consume_token(IN);
                        break;
                    case SN:
                        Jj_consume_token(SN);
                        break;
                    case SB:
                        Jj_consume_token(SB);
                        break;
                    case TE:
                        Jj_consume_token(TE);
                        break;
                    case XE:
                        Jj_consume_token(XE);
                        break;
                    case CS:
                        Jj_consume_token(CS);
                        break;
                    case BA:
                        Jj_consume_token(BA);
                        break;
                    case LA:
                        Jj_consume_token(LA);
                        break;
                    case HF:
                        Jj_consume_token(HF);
                        break;
                    case TA:
                        Jj_consume_token(TA);
                        break;
                    case W:
                        Jj_consume_token(W);
                        break;
                    case RE:
                        Jj_consume_token(RE);
                        break;
                    case OS:
                        Jj_consume_token(OS);
                        break;
                    case IR:
                        Jj_consume_token(IR);
                        break;
                    case PT:
                        Jj_consume_token(PT);
                        break;
                    case AU:
                        Jj_consume_token(AU);
                        break;
                    case HG:
                        Jj_consume_token(HG);
                        break;
                    case TL:
                        Jj_consume_token(TL);
                        break;
                    case PB:
                        Jj_consume_token(PB);
                        break;
                    case BI:
                        Jj_consume_token(BI);
                        break;
                    case PO:
                        Jj_consume_token(PO);
                        break;
                    case AT:
                        Jj_consume_token(AT);
                        break;
                    case RN:
                        Jj_consume_token(RN);
                        break;
                    case FR:
                        Jj_consume_token(FR);
                        break;
                    case RA:
                        Jj_consume_token(RA);
                        break;
                    case AC:
                        Jj_consume_token(AC);
                        break;
                    case TH:
                        Jj_consume_token(TH);
                        break;
                    case PA:
                        Jj_consume_token(PA);
                        break;
                    case CL:
                        Jj_consume_token(CL);
                        break;
                    case B:
                        Jj_consume_token(B);
                        break;
                    case C:
                        Jj_consume_token(C);
                        break;
                    case N:
                        Jj_consume_token(N);
                        break;
                    case O:
                        Jj_consume_token(O);
                        break;
                    case F:
                        Jj_consume_token(F);
                        break;
                    case P:
                        Jj_consume_token(P);
                        break;
                    case S:
                        Jj_consume_token(S);
                        break;
                    case K:
                        Jj_consume_token(K);
                        break;
                    case V:
                        Jj_consume_token(V);
                        break;
                    case Y:
                        Jj_consume_token(Y);
                        break;
                    case I:
                        Jj_consume_token(I);
                        break;
                    case U:
                        Jj_consume_token(U);
                        break;
                    case c:
                        Jj_consume_token(c);
                        break;
                    case o:
                        Jj_consume_token(o);
                        break;
                    case n:
                        Jj_consume_token(n);
                        break;
                    case s:
                        Jj_consume_token(s);
                        break;
                    case p:
                        Jj_consume_token(p);
                        break;
                    case as_:
                        Jj_consume_token(as_);
                        break;
                    case se:
                        Jj_consume_token(se);
                        break;
                    case PU:
                        Jj_consume_token(PU);
                        break;
                    case AM:
                        Jj_consume_token(AM);
                        break;
                    case CM:
                        Jj_consume_token(CM);
                        break;
                    case BK:
                        Jj_consume_token(BK);
                        break;
                    case CF:
                        Jj_consume_token(CF);
                        break;
                    case ES:
                        Jj_consume_token(ES);
                        break;
                    case FM:
                        Jj_consume_token(FM);
                        break;
                    case MD:
                        Jj_consume_token(MD);
                        break;
                    case NO:
                        Jj_consume_token(NO);
                        break;
                    case LR:
                        Jj_consume_token(LR);
                        break;
                    case NP:
                        Jj_consume_token(NP);
                        break;
                    case CE:
                        Jj_consume_token(CE);
                        break;
                    case ND:
                        Jj_consume_token(ND);
                        break;
                    case PM:
                        Jj_consume_token(PM);
                        break;
                    case SM:
                        Jj_consume_token(SM);
                        break;
                    case EU:
                        Jj_consume_token(EU);
                        break;
                    case GD:
                        Jj_consume_token(GD);
                        break;
                    case TB:
                        Jj_consume_token(TB);
                        break;
                    case DY:
                        Jj_consume_token(DY);
                        break;
                    case HO:
                        Jj_consume_token(HO);
                        break;
                    case ER:
                        Jj_consume_token(ER);
                        break;
                    case TM:
                        Jj_consume_token(TM);
                        break;
                    case YB:
                        Jj_consume_token(YB);
                        break;
                    case LU:
                        Jj_consume_token(LU);
                        break;
                    case PR:
                        Jj_consume_token(PR);
                        break;
                    default:
                        jj_la1[61] = jj_gen;
                        Jj_consume_token(-1);
                        throw new ParseException();
                }
                jjtree.CloseNodeScope(jjtn000, true);
                jjtc000 = false;
                jjtn000.Symbol = token.image;
            }
            finally
            {
                if (jjtc000)
                {
                    jjtree.CloseNodeScope(jjtn000, true);
                }
            }
        }

        private bool Jj_2_1(int xla)
        {
            jj_la = xla; jj_lastpos = jj_scanpos = token;
            try { return !Jj_3_1(); }
    catch (LookaheadSuccess) { return true; }
    finally { Jj_save(0, xla); }
        }

        private bool Jj_2_2(int xla)
        {
            jj_la = xla; jj_lastpos = jj_scanpos = token;
            try { return !Jj_3_2(); }
            catch  (LookaheadSuccess) { return true; }
    finally { Jj_save(1, xla); }
        }

        private bool Jj_3_1()
        {
            if (Jj_scan_token(S_BOND)) return true;
            return false;
        }

        private bool Jj_3_2()
        {
            if (Jj_scan_token(PLUS)) return true;
            Token xsp;
            xsp = jj_scanpos;
            if (Jj_3R_19()) jj_scanpos = xsp;
            return false;
        }

        private bool Jj_3R_20()
        {
            if (Jj_scan_token(DIGIT)) return true;
            return false;
        }

        private bool Jj_3R_19()
        {
            Token xsp;
            if (Jj_3R_20()) return true;
            while (true)
            {
                xsp = jj_scanpos;
                if (Jj_3R_20()) { jj_scanpos = xsp; break; }
            }
            return false;
        }

        /// <summary>Generated Token Manager.</summary>
        public SMARTSParserTokenManager token_source;
        SimpleCharStream jj_input_stream;
        /// <summary>Current token.</summary>
        public Token token;
        /// <summary>Next token.</summary>
        public Token jj_nt;
        private int jj_ntk;
        private Token jj_scanpos, jj_lastpos;
        private int jj_la;
        private int jj_gen;
        readonly private int[] jj_la1 = new int[62];
        static private int[] jj_la1_0;
        static private int[] jj_la1_1;
        static private int[] jj_la1_2;
        static private int[] jj_la1_3;
        static private int[] jj_la1_4;
        static private int[] jj_la1_5;
        static SMARTSParser() {
      Jj_la1_init_0();
      Jj_la1_init_1();
      Jj_la1_init_2();
      Jj_la1_init_3();
      Jj_la1_init_4();
      Jj_la1_init_5();
    }
        private static void Jj_la1_init_0()
        {
            unchecked
            {
                jj_la1_0 = new int[] { (int)0x3, (int)0xffff0000, (int)0xffff0000, (int)0xffff0000, (int)0x0, (int)0x0, (int)0xffff0000, (int)0x0, (int)0x0, (int)0xffff0000, (int)0xffffffe0, (int)0xffe0, (int)0x0, (int)0xffff0000, (int)0xffe0, (int)0xffffffe0, (int)0x0, (int)0x0, (int)0x0, (int)0x2000, (int)0xffff0000, (int)0x4, (int)0x10, (int)0x8, (int)0xffe0, (int)0x20, (int)0xff80, (int)0xffff0000, (int)0x4, (int)0x10, (int)0x8, (int)0xffff9060, (int)0x20, (int)0xffff9040, (int)0xffff9040, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x40, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x8000, (int)0x0, (int)0xffff0000, };
            }
        }
        private static void Jj_la1_init_1()
        {
            unchecked
            {
                jj_la1_1 = new int[] { (int)0x0, (int)0x18f, (int)0x18f, (int)0x18f, (int)0x0, (int)0x0, (int)0x18f, (int)0x0, (int)0x0, (int)0x18f, (int)0x9cf, (int)0x800, (int)0x40, (int)0xcf, (int)0x800, (int)0x9cf, (int)0x40, (int)0x20, (int)0x40, (int)0x0, (int)0x8f, (int)0x0, (int)0x0, (int)0x0, (int)0x800, (int)0x0, (int)0x800, (int)0xf, (int)0x0, (int)0x0, (int)0x0, (int)0xfffff81f, (int)0x0, (int)0xfffff81f, (int)0xfffff01f, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x0, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x40, (int)0x0, (int)0x20, (int)0xff800001, };
            }
        }
        private static void Jj_la1_init_2()
        {
            unchecked
            {
                jj_la1_2 = new int[] { (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0xffffffff, (int)0x0, (int)0xffffffff, (int)0xffffffff, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0xffffffff, };
            }
        }
        private static void Jj_la1_init_3()
        {
            unchecked
            {
                jj_la1_3 = new int[] { (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0xffffffff, (int)0x0, (int)0xffffffff, (int)0xffffffff, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0xffffffff, };
            }
        }
        private static void Jj_la1_init_4()
        {
            unchecked
            {
                jj_la1_4 = new int[] { (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x80000, (int)0x100000, (int)0x0, (int)0x100000, (int)0x100000, (int)0x0, (int)0x200000, (int)0x0, (int)0x200000, (int)0x200000, (int)0x0, (int)0x200000, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0xffc7ffff, (int)0x0, (int)0xffc7ffff, (int)0xffc7ffff, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0xffc00000, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x7ffff, };
            }
        }
        private static void Jj_la1_init_5()
        {
            unchecked
            {
                jj_la1_5 = new int[] { (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0xf, (int)0x0, (int)0xf, (int)0xf, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0xf, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, (int)0x0, };
            }
        }
    readonly private JJCalls[] jj_2_rtns = new JJCalls[2];
    private bool jj_rescan = false;
    private int jj_gc = 0;

    /// <summary>Constructor with InputStream.</summary>
    public SMARTSParser(Stream stream) : this(stream, null) {
    }
    /// <summary>Constructor with InputStream and supplied encoding</summary>
    public SMARTSParser(Stream stream, string encoding)
    {
        try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch (ArgumentException e) { throw e; } // unsupported encoding
        token_source = new SMARTSParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 62; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.Length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /// <summary>Reinitialise.</summary>
    public void ReInit(Stream stream)
    {
        ReInit(stream, null);
    }
    /// <summary>Reinitialise.</summary>
    public void ReInit(Stream stream, string encoding)
    {
        try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(ArgumentException e) { throw e; }// unsupported encoding
            token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jjtree.Reset();
        jj_gen = 0;
        for (int i = 0; i < 62; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.Length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /// <summary>Constructor.</summary>
    public SMARTSParser(TextReader stream)
    {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new SMARTSParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 62; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.Length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /// <summary>Reinitialise.</summary>
    public void ReInit(TextReader stream)
    {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jjtree.Reset();
        jj_gen = 0;
        for (int i = 0; i < 62; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.Length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /// <summary>Constructor with generated Token Manager.</summary>
    public SMARTSParser(SMARTSParserTokenManager tm)
    {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 62; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.Length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /// <summary>Reinitialise.</summary>
    public void ReInit(SMARTSParserTokenManager tm)
    {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jjtree.Reset();
        jj_gen = 0;
        for (int i = 0; i < 62; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.Length; i++) jj_2_rtns[i] = new JJCalls();
    }

    private Token Jj_consume_token(int kind)
    {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.GetNextToken();
        jj_ntk = -1;
        if (token.kind == kind)
        {
            jj_gen++;
            if (++jj_gc > 100)
            {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.Length; i++)
                {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null)
                    {
                        if (c.gen < jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw GenerateParseException();
    }
    
     private sealed class LookaheadSuccess : Exception { }
    readonly private LookaheadSuccess jj_ls = new LookaheadSuccess();
    private bool Jj_scan_token(int kind)
    {
        if (jj_scanpos == jj_lastpos)
        {
            jj_la--;
            if (jj_scanpos.next == null)
            {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.GetNextToken();
            }
            else
            {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        }
        else
        {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan)
        {
            int i = 0; Token tok = token;
            while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
            if (tok != null) Jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
        return false;
    }

    /// <summary>Get the next Token.</summary>
     public Token GetNextToken()
    {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.GetNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /// <summary>Get the specific Token.</summary>
     public Token GetToken(int index)
    {
        Token t = token;
        for (int i = 0; i < index; i++)
        {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.GetNextToken();
        }
        return t;
    }

    private int Jj_ntk()
    {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.GetNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private IList<int[]> jj_expentries = new List<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void Jj_add_error_token(int kind, int pos)
    {
        if (pos >= 100) return;
        if (pos == jj_endpos + 1)
        {
            jj_lasttokens[jj_endpos++] = kind;
        }
        else if (jj_endpos != 0)
        {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++)
            {
                jj_expentry[i] = jj_lasttokens[i];
            }
            jj_entries_loop:
            foreach (int[] oldentry in jj_expentries)
                {
                    if (oldentry.Length == jj_expentry.Length)
                {
                    for (int i = 0; i < jj_expentry.Length; i++)
                    {
                        if (oldentry[i] != jj_expentry[i])
                        {
                                goto continue_jj_entries_loop;
                        }
                    }
                    jj_expentries.Add(jj_expentry);
                    goto break_jj_entries_loop;
                }
                    continue_jj_entries_loop:
                    ;
            }
                break_jj_entries_loop:
            if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    /// <summary>Generate ParseException.</summary>
    public ParseException GenerateParseException()
    {
        jj_expentries.Clear();
        bool[] la1tokens = new bool[164];
        if (jj_kind >= 0)
        {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 62; i++)
        {
            if (jj_la1[i] == jj_gen)
            {
                for (int j = 0; j < 32; j++)
                {
                    if ((jj_la1_0[i] & (1 << j)) != 0)
                    {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0)
                    {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & (1 << j)) != 0)
                    {
                        la1tokens[64 + j] = true;
                    }
                    if ((jj_la1_3[i] & (1 << j)) != 0)
                    {
                        la1tokens[96 + j] = true;
                    }
                    if ((jj_la1_4[i] & (1 << j)) != 0)
                    {
                        la1tokens[128 + j] = true;
                    }
                    if ((jj_la1_5[i] & (1 << j)) != 0)
                    {
                        la1tokens[160 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 164; i++)
        {
            if (la1tokens[i])
            {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.Add(jj_expentry);
            }
        }
        jj_endpos = 0;
        Jj_rescan_token();
        Jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.Count][];
        for (int i = 0; i < jj_expentries.Count; i++)
        {
            exptokseq[i] = jj_expentries[i];
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /// <summary>Enable tracing.</summary>
     public void Enable_tracing()
    {
    }

    /// <summary>Disable tracing.</summary>
     public void Disable_tracing()
    {
    }

    private void Jj_rescan_token()
    {
        jj_rescan = true;
        for (int i = 0; i < 2; i++)
        {
            try
            {
                JJCalls p = jj_2_rtns[i];
                do
                {
                    if (p.gen > jj_gen)
                    {
                        jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
                        switch (i)
                        {
                            case 0: Jj_3_1(); break;
                            case 1: Jj_3_2(); break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (LookaheadSuccess ls) { }
        }
        jj_rescan = false;
    }

    private void Jj_save(int index, int xla)
    {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen)
        {
            if (p.next == null) { p = p.next = new JJCalls(); break; }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
    }

    sealed class JJCalls
    {
        internal int gen;
            internal Token first;
            internal int arg;
            internal JJCalls next;
    }

}
}
